{
  "AboutDialog": {
    "name": "AboutDialog",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "An about box. This is a dialog box with the application's icon, name,\nversion number, and copyright, plus a button to show licenses for software\nused by the application.\n\nTo show an [AboutDialog], use [showAboutDialog].\n\nIf the application has a [Drawer], the [AboutDrawerItem] widget can make the\nprocess of showing an about dialog simpler.\n\nThe [AboutDialog] shown by [showAboutDialog] includes a button that calls\n[showLicensePage].\n\nThe licenses shown on the [LicensePage] are those returned by the\n[LicenseRegistry] API, which can be used to add more licenses to the list.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "applicationName",
        "type": "String",
        "named": true,
        "docs": "The name of the application.\n\nDefaults to the value of [Title.title], if a [Title] widget can be found.\nOtherwise, defaults to [Platform.resolvedExecutable]."
      },
      {
        "name": "applicationVersion",
        "type": "String",
        "named": true,
        "docs": "The version of this build of the application.\n\nThis string is shown under the application name.\n\nDefaults to the empty string."
      },
      {
        "name": "applicationIcon",
        "type": "Widget",
        "named": true,
        "docs": "The icon to show next to the application name.\n\nBy default no icon is shown.\n\nTypically this will be an [ImageIcon] widget. It should honor the\n[IconTheme]'s [IconThemeData.size]."
      },
      {
        "name": "applicationLegalese",
        "type": "String",
        "named": true,
        "docs": "A string to show in small print.\n\nTypically this is a copyright notice.\n\nDefaults to the empty string."
      },
      {
        "name": "children",
        "type": "List",
        "named": true,
        "docs": "Widgets to add to the dialog box after the name, version, and legalese.\n\nThis could include a link to a Web site, some descriptive text, credits,\nor other information to show in the about box.\n\nDefaults to nothing."
      }
    ]
  },
  "AboutDrawerItem": {
    "name": "AboutDrawerItem",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A [DrawerItem] to show an about box.\n\nPlace this in a [Drawer], specifying your preferred application name,\nversion, icon, and copyright in the appropriate fields.\n\nThe about box will include a button that shows licenses for software used by\nthe application. The licenses shown are those returned by the\n[LicenseRegistry] API, which can be used to add more licenses to the list.\n\nIf your application does not have a [Drawer], you should provide an\naffordance to call [showAboutDialog] or (at least) [showLicensePage].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "icon",
        "type": "Widget",
        "named": true,
        "docs": "The icon to show for this drawer item.\n\nBy default no icon is shown.\n\nThis is not necessarily the same as the image shown in the dialog box\nitself; which is controlled by the [applicationIcon] property."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The label to show on this drawer item.\n\nDefaults to a text widget that says \"About Foo\" where \"Foo\" is the\napplication name specified by [applicationName]."
      },
      {
        "name": "applicationName",
        "type": "String",
        "named": true,
        "docs": "The name of the application.\n\nThis string is used in the default label for this drawer item (see\n[child]) and as the caption of the [AboutDialog] that is shown.\n\nDefaults to the value of [Title.title], if a [Title] widget can be found.\nOtherwise, defaults to [Platform.resolvedExecutable]."
      },
      {
        "name": "applicationVersion",
        "type": "String",
        "named": true,
        "docs": "The version of this build of the application.\n\nThis string is shown under the application name in the [AboutDialog].\n\nDefaults to the empty string."
      },
      {
        "name": "applicationIcon",
        "type": "Widget",
        "named": true,
        "docs": "The icon to show next to the application name in the [AboutDialog].\n\nBy default no icon is shown.\n\nTypically this will be an [ImageIcon] widget. It should honor the\n[IconTheme]'s [IconThemeData.size].\n\nThis is not necessarily the same as the icon shown on the drawer item\nitself, which is controlled by the [icon] property."
      },
      {
        "name": "applicationLegalese",
        "type": "String",
        "named": true,
        "docs": "A string to show in small print in the [AboutDialog].\n\nTypically this is a copyright notice.\n\nDefaults to the empty string."
      },
      {
        "name": "aboutBoxChildren",
        "type": "List",
        "named": true,
        "docs": "Widgets to add to the [AboutDialog] after the name, version, and legalese.\n\nThis could include a link to a Web site, some descriptive text, credits,\nor other information to show in the about box.\n\nDefaults to nothing."
      }
    ]
  },
  "AbsorbPointer": {
    "name": "AbsorbPointer",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that absorbs pointers during hit testing.\n\nWhen [absorbing] is true, this widget prevents its subtree from receiving\npointer events by terminating hit testing at itself. It still consumes space\nduring layout and paints its child as usual. It just prevents its children\nfrom being the target of located events, because it returns true from\n[hitTest].\n\nSee also:\n\n* [IgnorePointer], which also prevents its children from receiving pointer\nevents but is itself invisible to hit testing.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "absorbing",
        "type": "bool",
        "named": true,
        "docs": "Whether this widget absorbs pointers during hit testing.\n\nRegardless of whether this render object absorbs pointers during hit\ntesting, it will still consume space during layout and be visible during\npainting."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "AlertDialog": {
    "name": "AlertDialog",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design alert dialog.\n\nAn alert dialog informs the user about situations that require\nacknowledgement. An alert dialog has an optional title and an optional list\nof actions. The title is displayed above the content and the actions are\ndisplayed below the content.\n\nIf the content is too large to fit on the screen vertically, the dialog will\ndisplay the title and the actions and let the content overflow. Consider\nusing a scrolling widget, such as [ScrollList], for [content] to avoid\noverflow.\n\nFor dialogs that offer the user a choice between several options, consider\nusing a [SimpleDialog].\n\nTypically passed as the child widget to [showDialog], which displays the\ndialog.\n\nSee also:\n\n* [SimpleDialog], which handles the scrolling of the contents but has no [actions].\n* [Dialog], on which [AlertDialog] and [SimpleDialog] are based.\n* [showDialog], which actually displays the dialog and returns its result.\n* <https://material.google.com/components/dialogs.html#dialogs-alerts>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "docs": "The (optional) title of the dialog is displayed in a large font at the top\nof the dialog.\n\nTypically a [Text] widget."
      },
      {
        "name": "titlePadding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "Padding around the title.\n\nUses material design default if none is supplied. If there is no title, no\npadding will be provided."
      },
      {
        "name": "content",
        "type": "Widget",
        "named": true,
        "docs": "The (optional) content of the dialog is displayed in the center of the\ndialog in a lighter font.\n\nTypically, this is a [ScrollList] containing the contents of the dialog.\nUsing a [ScrollList] ensures that the contents can scroll if they are too\nbig to fit on the display."
      },
      {
        "name": "contentPadding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "Padding around the content.\n\nUses material design default if none is supplied."
      },
      {
        "name": "actions",
        "type": "List",
        "named": true,
        "docs": "The (optional) set of actions that are displayed at the bottom of the\ndialog.\n\nTypically this is a list of [FlatButton] widgets.\n\nThese widgets will be wrapped in a [ButtonBar]."
      }
    ]
  },
  "Align": {
    "name": "Align",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that aligns its child within itself and optionally sizes itself\nbased on the child's size.\n\nFor example, to align a box at the bottom right, you would pass this box a\ntight constraint that is bigger than the child's natural size,\nwith an alignment of [FractionalOffset.bottomRight].\n\nThis widget will be as big as possible if its dimensions are constrained and\n[widthFactor] and [heightFactor] are null. If a dimension is unconstrained\nand the corresponding size factor is null then the widget will match its\nchild's size in that dimension. If a size factor is non-null then the\ncorresponding dimension of this widget will be the product of the child's\ndimension and the size factor. For example if widthFactor is 2.0 then\nthe width of this widget will always be twice its child's width.\n\nSee also:\n\n* [CustomSingleChildLayout], which uses a delegate to control the layout of\na single child.\n* [Center], which is the same as [Align] but with the [alignment] always\nset to [FractionalOffset.center].\n* [FractionallySizedBox], which sizes its child based on a fraction of its own\nsize and positions the child according to a [FractionalOffset] value.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "How to align the child.\n\nThe x and y values of the alignment control the horizontal and vertical\nalignment, respectively.  An x value of 0.0 means that the left edge of\nthe child is aligned with the left edge of the parent whereas an x value\nof 1.0 means that the right edge of the child is aligned with the right\nedge of the parent. Other values interpolate (and extrapolate) linearly.\nFor example, a value of 0.5 means that the center of the child is aligned\nwith the center of the parent."
      },
      {
        "name": "widthFactor",
        "type": "double",
        "named": true,
        "docs": "If non-null, sets its width to the child's width multipled by this factor.\n\nCan be both greater and less than 1.0 but must be positive."
      },
      {
        "name": "heightFactor",
        "type": "double",
        "named": true,
        "docs": "If non-null, sets its height to the child's height multipled by this factor.\n\nCan be both greater and less than 1.0 but must be positive."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "AnimatedBuilder": {
    "name": "AnimatedBuilder",
    "package": "widgets",
    "parent": "AnimatedWidget",
    "docs": "A general-purpose widget for building animations.\n\nAnimatedBuilder is useful for more complex widgets that wish to include\nan animation as part of a larger build function. To use AnimatedBuilder,\nsimply construct the widget and pass it a builder function.\n\nIf your [builder] function contains a subtree that does not depend on the\nanimation, it's more efficient to build that subtree once instead of\nrebuilding it on every animation tick.\n\nIf you pass the pre-built subtree as the [child] parameter, the\nAnimatedBuilder will pass it back to your builder function so that you\ncan incorporate it into your build.\n\nUsing this pre-built child is entirely optional, but can improve\nperformance significantly in some cases and is therefore a good practice.\n\nFor simple cases without additional state, consider using\n[AnimatedWidget].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "animation",
        "type": "Animation",
        "named": true,
        "required": true
      },
      {
        "name": "builder",
        "type": "TransitionBuilder",
        "named": true,
        "required": true,
        "docs": "Called every time the animation changes value."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "If your builder function contains a subtree that does not depend on the\nanimation, it's more efficient to build that subtree once instead of\nrebuilding it on every animation tick.\n\nIf you pass the pre-built subtree as the [child] parameter, the\nAnimatedBuilder will pass it back to your builder function so that you\ncan incorporate it into your build.\n\nUsing this pre-built child is entirely optional, but can improve\nperformance significantly in some cases and is therefore a good practice."
      }
    ]
  },
  "AnimatedContainer": {
    "name": "AnimatedContainer",
    "package": "widgets",
    "parent": "ImplicitlyAnimatedWidget",
    "docs": "A container that gradually changes its values over a period of time.\n\nThis class is useful for generating simple implicit transitions between\ndifferent parameters to [Container]. For more complex animations, you'll\nlikely want to use a subclass of [Transition] or use an\n[AnimationController] yourself.\n\nProperties that are null are not animated.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "constraints",
        "type": "BoxConstraints",
        "named": true,
        "docs": "Additional constraints to apply to the child."
      },
      {
        "name": "decoration",
        "type": "Decoration",
        "named": true,
        "docs": "The decoration to paint behind the child."
      },
      {
        "name": "foregroundDecoration",
        "type": "Decoration",
        "named": true,
        "docs": "The decoration to paint in front of the child."
      },
      {
        "name": "margin",
        "type": "EdgeInsets",
        "named": true,
        "docs": "Empty space to surround the decoration."
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "Empty space to inscribe inside the decoration."
      },
      {
        "name": "transform",
        "type": "Matrix4",
        "named": true,
        "docs": "The transformation matrix to apply before painting the container."
      },
      {
        "name": "width",
        "type": "double",
        "named": true,
        "docs": "If non-null, requires the decoration to have this width."
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "If non-null, requires the decoration to have this height."
      },
      {
        "name": "curve",
        "type": "Curve",
        "named": true
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "required": true
      }
    ]
  },
  "AnimatedCrossFade": {
    "name": "AnimatedCrossFade",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that cross-fades between two given children and animates itself\nbetween their sizes.\n\nThe animation is controlled through the [crossFadeState] parameter.\n[firstCurve] and [secondCurve] represent the opacity curves of the two\nchildren. Note that [firstCurve] is inverted, i.e. it fades out when\nproviding a growing curve like [Curves.linear]. [sizeCurve] is the curve\nused to animated between the size of the fading out child and the size of\nthe fading in child.\n\nThis widget is intended to be used to fade a pair of widgets with the same\nwidth. In the case where the two children have different heights, the\nanimation crops overflowing children during the animation by aligning their\ntop edge, which means that the bottom will be clipped.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "firstChild",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The child that is visible when [crossFadeState] is [showFirst]. It fades\nout when transitioning from [showFirst] to [showSecond] and vice versa."
      },
      {
        "name": "secondChild",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The child that is visible when [crossFadeState] is [showSecond]. It fades\nin when transitioning from [showFirst] to [showSecond] and vice versa."
      },
      {
        "name": "firstCurve",
        "type": "Curve",
        "named": true,
        "docs": "The fade curve of the first child."
      },
      {
        "name": "secondCurve",
        "type": "Curve",
        "named": true,
        "docs": "The fade curve of the second child."
      },
      {
        "name": "sizeCurve",
        "type": "Curve",
        "named": true,
        "docs": "The curve of the animation between the two children's sizes."
      },
      {
        "name": "crossFadeState",
        "type": "CrossFadeState",
        "named": true,
        "required": true,
        "docs": "The child that will be shown when the animation has completed."
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "required": true,
        "docs": "The duration of the whole orchestrated animation."
      }
    ]
  },
  "AnimatedDefaultTextStyle": {
    "name": "AnimatedDefaultTextStyle",
    "package": "widgets",
    "parent": "ImplicitlyAnimatedWidget",
    "docs": "Animated version of [DefaultTextStyle] which automatically\ntransitions the default text style (the text style to apply to\ndescendant [Text] widgets without explicit style) over a given\nduration whenever the given style changes.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "style",
        "type": "TextStyle",
        "named": true,
        "required": true,
        "docs": "The target text style.\n\nThe text style must not be null."
      },
      {
        "name": "curve",
        "type": "Curve",
        "named": true
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "required": true
      }
    ]
  },
  "AnimatedModalBarrier": {
    "name": "AnimatedModalBarrier",
    "package": "widgets",
    "parent": "AnimatedWidget",
    "docs": "A widget that prevents the user from interacting with widgets behind itself.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "color",
        "type": "Animation",
        "named": true
      },
      {
        "name": "dismissable",
        "type": "bool",
        "named": true,
        "docs": "Whether touching the barrier will pop the current route off the [Navigator]."
      }
    ]
  },
  "AnimatedOpacity": {
    "name": "AnimatedOpacity",
    "package": "widgets",
    "parent": "ImplicitlyAnimatedWidget",
    "docs": "Animated version of [Opacity] which automatically transitions the child's\nopacity over a given duration whenever the given opacity changes.\n\nAnimating an opacity is relatively expensive.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "opacity",
        "type": "double",
        "named": true,
        "docs": "The target opacity.\n\nAn opacity of 1.0 is fully opaque. An opacity of 0.0 is fully transparent\n(i.e., invisible).\n\nThe opacity must not be null."
      },
      {
        "name": "curve",
        "type": "Curve",
        "named": true
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "required": true
      }
    ]
  },
  "AnimatedPositioned": {
    "name": "AnimatedPositioned",
    "package": "widgets",
    "parent": "ImplicitlyAnimatedWidget",
    "docs": "Animated version of [Positioned] which automatically transitions the child's\nposition over a given duration whenever the given position changes.\n\nOnly works if it's the child of a [Stack].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "left",
        "type": "double",
        "named": true,
        "docs": "The offset of the child's left edge from the left of the stack."
      },
      {
        "name": "top",
        "type": "double",
        "named": true,
        "docs": "The offset of the child's top edge from the top of the stack."
      },
      {
        "name": "right",
        "type": "double",
        "named": true,
        "docs": "The offset of the child's right edge from the right of the stack."
      },
      {
        "name": "bottom",
        "type": "double",
        "named": true,
        "docs": "The offset of the child's bottom edge from the bottom of the stack."
      },
      {
        "name": "width",
        "type": "double",
        "named": true,
        "docs": "The child's width.\n\nOnly two out of the three horizontal values (left, right, width) can be\nset. The third must be null."
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "The child's height.\n\nOnly two out of the three vertical values (top, bottom, height) can be\nset. The third must be null."
      },
      {
        "name": "curve",
        "type": "Curve",
        "named": true
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "required": true
      }
    ]
  },
  "AnimatedSize": {
    "name": "AnimatedSize",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "Animated widget that automatically transitions its size over a given\nduration whenever the given child's size changes.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "The alignment of the child within the parent when the parent is not yet\nthe same size as the child.\n\nThe x and y values of the alignment control the horizontal and vertical\nalignment, respectively. An x value of 0.0 means that the left edge of\nthe child is aligned with the left edge of the parent whereas an x value\nof 1.0 means that the right edge of the child is aligned with the right\nedge of the parent. Other values interpolate (and extrapolate) linearly.\nFor example, a value of 0.5 means that the center of the child is aligned\nwith the center of the parent."
      },
      {
        "name": "curve",
        "type": "Curve",
        "named": true,
        "docs": "The animation curve when transitioning this widget's size to match the\nchild's size."
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "required": true,
        "docs": "The duration when transitioning this widget's size to match the child's\nsize."
      },
      {
        "name": "vsync",
        "type": "TickerProvider",
        "named": true,
        "required": true,
        "docs": "The [TickerProvider] for this widget."
      }
    ]
  },
  "AnimatedTheme": {
    "name": "AnimatedTheme",
    "package": "material",
    "parent": "ImplicitlyAnimatedWidget",
    "docs": "Animated version of [Theme] which automatically transitions the colors,\netc, over a given duration whenever the given theme changes.\n\nSee also:\n\n* [Theme], which [AnimatedTheme] uses to actually apply the interpolated\ntheme.\n* [ThemeData], which describes the actual configuration of a theme.\n* [MaterialApp], which includes an [AnimatedTheme] widget configured via\nthe [MaterialApp.theme] argument.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "data",
        "type": "ThemeData",
        "named": true,
        "required": true,
        "docs": "Specifies the color and typography values for descendant widgets."
      },
      {
        "name": "isMaterialAppTheme",
        "type": "bool",
        "named": true,
        "docs": "True if this theme was created by the [MaterialApp]. See [Theme.isMaterialAppTheme]."
      },
      {
        "name": "curve",
        "type": "Curve",
        "named": true
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "AnimatedWidget": {
    "name": "AnimatedWidget",
    "package": "widgets",
    "parent": "StatefulWidget",
    "abstract": true,
    "docs": "A widget that rebuilds when the given animation changes value.\n\nAnimatedWidget is most useful for stateless animated widgets. To use\nAnimatedWidget, simply subclass it and implement the build function.\n\nFor more complex case involving additional state, consider using\n[AnimatedBuilder].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "animation",
        "type": "Animation",
        "named": true,
        "required": true,
        "docs": "The animation to which this widget is listening."
      }
    ]
  },
  "AppBar": {
    "name": "AppBar",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design app bar.\n\nAn app bar consists of a toolbar and potentially other widgets, such as a\n[TabBar] and a [FlexibleSpaceBar]. App bars typically expose one or more\ncommon actions with [IconButton]s which are optionally followed by a\n[PopupMenuButton] for less common operations.\n\nApp bars are typically used in the [Scaffold.appBar] property, which places\nthe app bar as a fixed-height widget at the top of the screen. For a\nscrollable app bar, see [SliverAppBar], which embeds an [AppBar] in a sliver\nfor use in a [CustomScrollView].\n\nThe AppBar displays the toolbar widgets, [leading], [title], and\n[actions], above the [bottom] (if any). If a [flexibleSpace] widget is\nspecified then it is stacked behind the toolbar and the bottom widget.\n\nSee also:\n\n* [Scaffold], which displays the [AppBar] in its [Scaffold.appBar] slot.\n* [SliverAppBar], which uses [AppBar] to provide a flexible app bar that\ncan be used in a [CustomScrollView].\n* [TabBar], which is typically placed in the [bottom] slot of the [AppBar]\nif the screen has multiple pages arranged in tabs.\n* [IconButton], which is used with [actions] to show buttons on the app bar.\n* [PopupMenuButton], to show a popup menu on the app bar, via [actions].\n* [FlexibleSpaceBar], which is used with [flexibleSpace] when the app bar\ncan expand and collapse.\n* <https://material.google.com/layout/structure.html#structure-toolbars>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "leading",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display before the [title].\n\nIf this is null, the [AppBar] will imply an appropriate widget. For\nexample, if the [AppBar] is in a [Scaffold] that also has a [Drawer], the\n[Scaffold] will fill this widget with an [IconButton] that opens the\ndrawer. If there's no [Drawer] and the parent [Navigator] can go back, the\n[AppBar] will use an [IconButton] that calls [Navigator.pop]."
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "docs": "The primary widget displayed in the appbar.\n\nTypically a [Text] widget containing a description of the current contents\nof the app."
      },
      {
        "name": "actions",
        "type": "List",
        "named": true,
        "docs": "Widgets to display after the [title] widget.\n\nTypically these widgets are [IconButton]s representing common operations.\nFor less common operations, consider using a [PopupMenuButton] as the\nlast action.\n\nFor example:\n\n```dart\nreturn new Scaffold(\nappBar: new AppBar(\ntitle: new Text('Hello World'),\nactions: <Widget>[\nnew IconButton(\nicon: new Icon(Icons.shopping_cart),\ntooltip: 'Open shopping cart',\nonPressed: _openCart,\n),\n],\n),\nbody: _buildBody(),\n);\n```"
      },
      {
        "name": "flexibleSpace",
        "type": "Widget",
        "named": true,
        "docs": "This widget is stacked behind the toolbar and the tabbar. It's height will\nbe the same as the the app bar's overall height.\n\nA flexible space isn't actually flexible unless the [AppBar]'s container\nchanges the [AppBar]'s size. A [SliverAppBar] in a [CustomScrollView]\nchanges the [AppBar]'s height when scrolled. A [Scaffold] always sets the\n[AppBar] to the [minExtent].\n\nTypically a [FlexibleSpaceBar]. See [FlexibleSpaceBar] for details."
      },
      {
        "name": "bottom",
        "type": "AppBarBottomWidget",
        "named": true
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this app bar.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 4, the appropriate elevation for app bars."
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use for the app bar's material. Typically this should be set\nalong with [brightness], [iconTheme], [textTheme].\n\nDefaults to [ThemeData.primaryColor]."
      },
      {
        "name": "brightness",
        "type": "Brightness",
        "named": true,
        "docs": "The brightness of the app bar's material. Typically this is set along\nwith [backgroundColor], [iconTheme], [textTheme].\n\nDefaults to [ThemeData.primaryColorBrightness]."
      },
      {
        "name": "iconTheme",
        "type": "IconThemeData",
        "named": true,
        "docs": "The color, opacity, and size to use for app bar icons. Typically this\nis set along with [backgroundColor], [brightness], [textTheme].\n\nDefaults to [ThemeData.primaryIconTheme]."
      },
      {
        "name": "textTheme",
        "type": "TextTheme",
        "named": true,
        "docs": "The typographic styles to use for text in the app bar. Typically this is\nset along with [brightness] [backgroundColor], [iconTheme].\n\nDefaults to [ThemeData.primaryTextTheme]."
      },
      {
        "name": "primary",
        "type": "bool",
        "named": true,
        "docs": "Whether this app bar is being displayed at the top of the screen.\n\nIf this is true, the top padding specified by the [MediaQuery] will be\nadded to the top of the toolbar. See also [minExtent]."
      },
      {
        "name": "centerTitle",
        "type": "bool",
        "named": true,
        "docs": "Whether the title should be centered.\n\nDefaults to being adapted to the current [TargetPlatform]."
      },
      {
        "name": "toolbarOpacity",
        "type": "double",
        "named": true,
        "docs": "How opaque the toolbar part of the app bar is.\n\nA value of 1.0 is fully opaque, and a value of 0.0 is fully transparent.\n\nTypically, this value is not changed from its default value (1.0). It is\nused by [SliverAppBar] to animate the opacity of the toolbar when the app\nbar is scrolled."
      },
      {
        "name": "bottomOpacity",
        "type": "double",
        "named": true,
        "docs": "How opaque the bottom part of the app bar is.\n\nA value of 1.0 is fully opaque, and a value of 0.0 is fully transparent.\n\nTypically, this value is not changed from its default value (1.0). It is\nused by [SliverAppBar] to animate the opacity of the toolbar when the app\nbar is scrolled."
      }
    ]
  },
  "AppBarBottomWidget": {
    "name": "AppBarBottomWidget",
    "package": "material",
    "parent": "Widget",
    "abstract": true,
    "docs": "An interface for widgets that can appear at the bottom of an [AppBar] or\n[SliverAppBar].\n\nThis interface exposes the height of the widget, so that the [Scaffold] and\n[SliverAppBar] widgets can correctly size an [AppBar]."
  },
  "AspectRatio": {
    "name": "AspectRatio",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that attempts to size the child to a specific aspect ratio.\n\nThe widget first tries the largest width permited by the layout\nconstraints. The height of the widget is determined by applying the\ngiven aspect ratio to the width, expressed as a ratio of width to height.\n\nFor example, a 16:9 width:height aspect ratio would have a value of\n16.0/9.0. If the maximum width is infinite, the initial width is determined\nby applying the aspect ratio to the maximum height.\n\nNow consider a second example, this time with an aspect ratio of 2.0 and\nlayout constraints that require the width to be between 0.0 and 100.0 and\nthe height to be between 0.0 and 100.0. We'll select a width of 100.0 (the\nbiggest allowed) and a height of 50.0 (to match the aspect ratio).\n\nIn that same situation, if the aspect ratio is 0.5, we'll also select a\nwidth of 100.0 (still the biggest allowed) and we'll attempt to use a height\nof 200.0. Unfortunately, that violates the constraints because the child can\nbe at most 100.0 pixels tall. The widget will then take that value\nand apply the aspect ratio again to obtain a width of 50.0. That width is\npermitted by the constraints and the child receives a width of 50.0 and a\nheight of 100.0. If the width were not permitted, the widget would\ncontinue iterating through the constraints. If the widget does not\nfind a feasible size after consulting each constraint, the widget\nwill eventually select a size for the child that meets the layout\nconstraints but fails to meet the aspect ratio constraints.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "aspectRatio",
        "type": "double",
        "named": true,
        "required": true,
        "docs": "The aspect ratio to attempt to use.\n\nThe aspect ratio is expressed as a ratio of width to height. For example,\na 16:9 width:height aspect ratio would have a value of 16.0/9.0."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "BackdropFilter": {
    "name": "BackdropFilter",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that applies a filter to the existing painted content and then paints [child].\n\nThis effect is relatively expensive, especially if the filter is non-local,\nsuch as a blur.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "filter",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The image filter to apply to the existing painted content before painting the child.\n\nFor example, consider using [ui.ImageFilter.blur] to create a backdrop\nblur effect"
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Banner": {
    "name": "Banner",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "Displays a diagonal message above the corner of another widget.\n\nUseful for showing the execution mode of an app (e.g., that asserts are\nenabled.)\n\nSee also:\n\n* [CheckedModeBanner].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget to show behind the banner."
      },
      {
        "name": "message",
        "type": "String",
        "named": true,
        "required": true,
        "docs": "The message to show in the banner."
      },
      {
        "name": "location",
        "type": "BannerLocation",
        "named": true,
        "required": true,
        "docs": "Where to show the banner (e.g., the upper right corder)."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color of the banner."
      },
      {
        "name": "textStyle",
        "type": "TextStyle",
        "named": true,
        "docs": "The style of the text shown on the banner."
      }
    ]
  },
  "Baseline": {
    "name": "Baseline",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that positions its child according to the child's baseline.\n\nThis widget shifts the child down such that the child's baseline (or the\nbottom of the child, if the child has no baseline) is [baseline]\nlogical pixels below the top of this box, then sizes this box to\ncontain the child. If [baseline] is less than the distance from\nthe top of the child to the baseline of the child, then the child\nis top-aligned instead.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "baseline",
        "type": "double",
        "named": true,
        "required": true,
        "docs": "The number of logical pixels from the top of this box at which to position\nthe child's baseline."
      },
      {
        "name": "baselineType",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The type of baseline to use for positioning the child."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "BlockBody": {
    "name": "BlockBody",
    "package": "widgets",
    "parent": "MultiChildRenderObjectWidget",
    "docs": "A widget that uses the block layout algorithm for its children.\n\nThis widget is rarely used directly. Instead, consider using [SliverList],\nwhich combines a similar layout algorithm with scrolling behavior, or\n[Column], which gives you more flexible control over the layout of a\nvertical set of boxes.\n\nFor details about the block layout algorithm, see [RenderBlockBase].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "mainAxis",
        "type": "Axis",
        "named": true,
        "docs": "The direction to use as the main axis."
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "BottomNavigationBar": {
    "name": "BottomNavigationBar",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material widget displayed at the bottom of an app for selecting among a\nsmall number of views.\n\nThe bottom navigation bar consists of multiple items in the form of\nlabels, icons, or both, laid out on top of a piece of material. It provides\nquick navigation between the top-level views of an app. For larger screens,\nside navigation may be a better fit.\n\nA bottom navigation bar is usually used in conjunction with [Scaffold] where\nit is provided as the [Scaffold.bottomNavigationBar] argument.\n\nSee also:\n\n* [BottomNavigationBarItem]\n* [Scaffold]\n* <https://material.google.com/components/bottom-navigation.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "items",
        "type": "List",
        "named": true,
        "required": true,
        "docs": "The interactive items laid out within the bottom navigation bar."
      },
      {
        "name": "onTap",
        "type": "ValueChanged",
        "named": true,
        "docs": "The callback that is called when a item is tapped.\n\nThe widget creating the bottom navigation bar needs to keep track of the\ncurrent index and call `setState` to rebuild it with the newly provided\nindex."
      },
      {
        "name": "currentIndex",
        "type": "int",
        "named": true,
        "docs": "The index into [items] of the current active item."
      },
      {
        "name": "type",
        "type": "BottomNavigationBarType",
        "named": true,
        "docs": "Defines the layout and behavior of a [BottomNavigationBar]."
      },
      {
        "name": "fixedColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color of the selected item when bottom navigation bar is\n[BottomNavigationBarType.fixed]."
      },
      {
        "name": "iconSize",
        "type": "double",
        "named": true,
        "docs": "The size of all of the [BottomNavigationBarItem] icons.\n\nThis value is used to to configure the [IconTheme] for the navigation\nbar. When a [BottomNavigationBarItem.icon] widget is not an [Icon] the widget\nshould configure itself to match the icon theme's size and color."
      }
    ]
  },
  "BottomSheet": {
    "name": "BottomSheet",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design bottom sheet.\n\nThere are two kinds of bottom sheets in material design:\n\n* _Persistent_. A persistent bottom sheet shows information that\nsupplements the primary content of the app. A persistent bottom sheet\nremains visible even when the user interacts with other parts of the app.\nPersistent bottom sheets can be created and displayed with the\n[Scaffold.showBottomSheet] function.\n\n* _Modal_. A modal bottom sheet is an alternative to a menu or a dialog and\nprevents the user from interacting with the rest of the app. Modal bottom\nsheets can be created and displayed with the [showModalBottomSheet]\nfunction.\n\nThe [BottomSheet] widget itself is rarely used directly. Instead, prefer to\ncreate a persistent bottom sheet with [Scaffold.showBottomSheet] and a modal\nbottom sheet with [showModalBottomSheet].\n\nSee also:\n\n* [Scaffold.showBottomSheet]\n* [showModalBottomSheet]\n* <https://material.google.com/components/bottom-sheets.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "animationController",
        "type": "AnimationController",
        "named": true,
        "docs": "The animation that controls the bottom sheet's position.\n\nThe BottomSheet widget will manipulate the position of this animation, it\nis not just a passive observer."
      },
      {
        "name": "onClosing",
        "type": "dynamic",
        "named": true,
        "docs": "Called when the bottom sheet begins to close.\n\nA bottom sheet might be be prevented from closing (e.g., by user\ninteraction) even after this callback is called. For this reason, this\ncallback might be call multiple times for a given bottom sheet."
      },
      {
        "name": "builder",
        "type": "WidgetBuilder",
        "named": true,
        "docs": "A builder for the contents of the sheet.\n\nThe bottom sheet will wrap the widget produced by this builder in a\n[Material] widget."
      }
    ]
  },
  "BoxScrollView": {
    "name": "BoxScrollView",
    "package": "widgets",
    "parent": "ScrollView",
    "abstract": true,
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "scrollDirection",
        "type": "Axis",
        "named": true
      },
      {
        "name": "reverse",
        "type": "bool",
        "named": true
      },
      {
        "name": "controller",
        "type": "ScrollController",
        "named": true
      },
      {
        "name": "primary",
        "type": "bool",
        "named": true
      },
      {
        "name": "physics",
        "type": "ScrollPhysics",
        "named": true
      },
      {
        "name": "shrinkWrap",
        "type": "bool",
        "named": true
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true
      }
    ]
  },
  "Builder": {
    "name": "Builder",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A platonic widget that calls a closure to obtain its child widget.\n\nSee also:\n\n* [StatefulBuilder], a platonic widget which also has state.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "builder",
        "type": "WidgetBuilder",
        "named": true,
        "required": true,
        "docs": "Called to obtain the child widget.\n\nThis function is called whenever this widget is included in its parent's\nbuild and the old widget (if any) that it synchronizes with has a distinct\nobject identity. Typically the parent's build method will construct\na new tree of widgets and so a new Builder child will not be [identical]\nto the corresponding old one."
      }
    ]
  },
  "ButtonBar": {
    "name": "ButtonBar",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A horizontal arrangement of buttons.\n\nPlaces the buttons horizontally according to the padding in the current\n[ButtonTheme].\n\nUsed by [Dialog] to arrange the actions at the bottom of the dialog.\n\nSee also:\n\n* [RaisedButton], a kind of button.\n* [FlatButton], another kind of button.\n* [Card], at the bottom of which it is common to place a [ButtonBar].\n* [Dialog], which uses a [ButtonBar] for its actions.\n* [ButtonTheme], which configures the [ButtonBar].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "alignment",
        "type": "MainAxisAlignment",
        "named": true,
        "docs": "How the children should be placed along the horizontal axis."
      },
      {
        "name": "mainAxisSize",
        "type": "MainAxisSize",
        "named": true,
        "docs": "How much horizontal space is available. See [Row.mainAxisSize]."
      },
      {
        "name": "children",
        "type": "List",
        "named": true,
        "docs": "The buttons to arrange horizontally.\n\nTypically [RaisedButton] or [FlatButton] widgets."
      }
    ]
  },
  "ButtonTheme": {
    "name": "ButtonTheme",
    "package": "material",
    "parent": "InheritedWidget",
    "docs": "Defines the button color used by a widget subtree.\n\nSee also:\n\n* [ButtonTextTheme]\n* [RaisedButton]\n* [FlatButton]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "textTheme",
        "type": "ButtonTextTheme",
        "named": true,
        "docs": "The button color that this subtree should use."
      },
      {
        "name": "minWidth",
        "type": "double",
        "named": true,
        "docs": "The smallest horizontal extent that the button will occupy.\n\nDefaults to 88.0 logical pixels."
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "The vertical extent of the button.\n\nDefaults to 36.0 logical pixels."
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "The amount of space to surround the child inside the bounds of the button.\n\nDefaults to 16.0 pixels of horizontal padding."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Card": {
    "name": "Card",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design card. A card has slightly rounded corners and a shadow.\n\nA card is a sheet of [Material] used to represent some related information,\nfor example an album, a geographical location, a meal, contact details, etc.\n\nSee also:\n\n* [ListItem], to display icons and text in a card.\n* [ButtonBar], to display buttons at the bottom of a card. Typically these\nwould be styled using a ButtonTheme created with [new ButtonTheme.bar].\n* [showDialog], to display a modal card.\n* <https://material.google.com/components/cards.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color of material used for this card."
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this card.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 2, the appropriate elevation for cards."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "Center": {
    "name": "Center",
    "package": "widgets",
    "parent": "Align",
    "docs": "A widget that centers its child within itself.\n\nSee also:\n\n* [Align], which lets you arbitrarily position a child within itself,\nrather than just centering it.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "widthFactor",
        "type": "double",
        "named": true
      },
      {
        "name": "heightFactor",
        "type": "double",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Checkbox": {
    "name": "Checkbox",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design checkbox\n\nThe checkbox itself does not maintain any state. Instead, when the state of\nthe checkbox changes, the widget calls the [onChanged] callback. Most\nwidgets that use a checkbox will listen for the [onChanged] callback and\nrebuild the checkbox with a new [value] to update the visual appearance of\nthe checkbox.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [Radio]\n* [Switch]\n* [Slider]\n* <https://material.google.com/components/selection-controls.html#selection-controls-checkbox>\n* <https://material.google.com/components/lists-controls.html#lists-controls-types-of-list-controls>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "bool",
        "named": true,
        "required": true,
        "docs": "Whether this checkbox is checked."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the value of the checkbox should change.\n\nThe checkbox passes the new value to the callback but does not actually\nchange state until the parent widget rebuilds the checkbox with the new\nvalue.\n\nIf null, the checkbox will be displayed as disabled.\n\nThe callback provided to onChanged should update the state of the parent\n[StatefulWidget] using the [State.setState] method, so that the parent\ngets rebuilt; for example:\n\n```dart\nnew Checkbox(\nvalue: _throwShotAway,\nonChanged: (bool newValue) {\nsetState(() {\n_throwShotAway = newValue;\n});\n},\n),\n```"
      },
      {
        "name": "activeColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use when this checkbox is checked.\n\nDefaults to accent color of the current [Theme]."
      }
    ]
  },
  "CheckedModeBanner": {
    "name": "CheckedModeBanner",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "Displays a [Banner] saying \"SLOW MODE\" when running in checked mode.\n[MaterialApp] builds one of these by default.\nDoes nothing in release mode.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget to show behind the banner."
      }
    ]
  },
  "CheckedPopupMenuItem": {
    "name": "CheckedPopupMenuItem",
    "package": "material",
    "parent": "PopupMenuItem",
    "docs": "An item with a checkmark in a material design popup menu.\n\nTo show a popup menu, use the [showMenu] function. To create a button that\nshows a popup menu, consider using [PopupMenuButton].\n\nSee also:\n\n* [PopupMenuItem]\n* [PopupMenuDivider]\n* [CheckedPopupMenuItem]\n* [showMenu]\n* [PopupMenuButton]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "T",
        "named": true
      },
      {
        "name": "checked",
        "type": "bool",
        "named": true,
        "docs": "Whether to display a checkmark next to the menu item."
      },
      {
        "name": "enabled",
        "type": "bool",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Chip": {
    "name": "Chip",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design chip.\n\nChips represent complex entities in small blocks, such as a contact.\n\nSupplying a non-null [onDeleted] callback will cause the chip to include a\nbutton for deleting the chip.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [CircleAvatar]\n* <https://material.google.com/components/chips.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "avatar",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display prior to the chip's label.\n\nTypically a [CircleAvatar] widget."
      },
      {
        "name": "label",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The primary content of the chip.\n\nTypically a [Text] widget."
      },
      {
        "name": "onDeleted",
        "type": "dynamic",
        "named": true,
        "docs": "Called when the user deletes the chip, e.g., by tapping the delete button.\n\nThe delete button is included in the chip only if this callback is non-null."
      }
    ]
  },
  "CircleAvatar": {
    "name": "CircleAvatar",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A circle that represents a user.\n\nTypically used with a user's profile image, or, in the absence of\nsuch an image, the user's initials. A given user's initials should\nalways be paired with the same background color, for consistency.\n\nIf the avatar is to have an image, the image should be specified in the\n[backgroundImage] property:\n\n```dart\nnew CircleAvatar(\nbackgroundImage: new NetworkImage(userAvatarUrl),\n)\n```\n\nThe image will be cropped to have a circle shape.\n\nIf the avatar is to just have the user's initials, they are typically\nprovided using a [Text] widget as the [child] and a [backgroundColor]:\n\n```dart\nnew CircleAvatar(\nbackgroundColor: Colors.brown[800],\nchild: new Text('AH'),\n);\n```\n\nSee also:\n\n* [Chip], for representing users or concepts in long form.\n* [ListItem], which combines an icon (such as a [CircleAvatar]) with some\ntext in a horizontal row.\n* <https://material.google.com/components/chips.html#chips-contact-chips>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree.\n\nTypically a [Text] widget. If the [CircleAvatar] is to have an image, use\n[backgroundImage] instead."
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color with which to fill the circle. Changing the background\ncolor will cause the avatar to animate to the new color."
      },
      {
        "name": "backgroundImage",
        "type": "ImageProvider",
        "named": true,
        "docs": "The background image of the circle. Changing the background\nimage will cause the avatar to animate to the new image.\n\nIf the [CircleAvatar] is to have the user's initials, use [child] instead."
      },
      {
        "name": "radius",
        "type": "double",
        "named": true,
        "docs": "The size of the avatar. Changing the radius will cause the\navatar to animate to the new size.\n\nDefaults to 20 logical pixels."
      }
    ]
  },
  "CircularProgressIndicator": {
    "name": "CircularProgressIndicator",
    "package": "material",
    "parent": "ProgressIndicator",
    "docs": "A material design circular progress indicator.\n\nA widget that shows progress along a circle. There are two kinds of circular\nprogress indicators:\n\n* _Determinate_. Determinate progress indicators have a specific value at\neach point in time, and the value should increase monotonically from 0.0\nto 1.0, at which time the indicator is complete. To create a determinate\nprogress indicator, use a non-null [value] between 0.0 and 1.0.\n* _Indeterminate_. Indeterminate progress indicators do not have a specific\nvalue at each point in time and instead indicate that progress is being\nmade without indicating how much progress remains. To create an\nindeterminate progress indicator, use a null [value].\n\nSee also:\n\n* [LinearProgressIndicator]\n* <https://material.google.com/components/progress-activity.html#progress-activity-types-of-indicators>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "double",
        "named": true
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true
      },
      {
        "name": "valueColor",
        "type": "Animation",
        "named": true
      }
    ]
  },
  "ClipOval": {
    "name": "ClipOval",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that clips its child using an oval.\n\nBy default, inscribes an axis-aligned oval into its layout dimensions and\nprevents its child from painting outside that oval, but the size and\nlocation of the clip oval can be customized using a custom [clipper].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "clipper",
        "type": "CustomClipper",
        "named": true,
        "docs": "If non-null, determines which clip to use.\n\nThe delegate returns a rectangle that describes the axis-aligned\nbounding box of the oval. The oval's axes will themselves also\nbe axis-aligned.\n\nIf the [clipper] delegate is null, then the oval uses the\nwidget's bounding box (the layout dimensions of the render\nobject) instead."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "ClipPath": {
    "name": "ClipPath",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that clips its child using a path.\n\nCalls a callback on a delegate whenever the widget is to be\npainted. The callback returns a path and the widget prevents the\nchild from painting outside the path.\n\nClipping to a path is expensive. Certain shapes have more\noptimized widgets:\n\n* To clip to a rectangle, consider [ClipRect].\n* To clip to an oval or circle, consider [ClipOval].\n* To clip to a rounded rectangle, consider [ClipRRect].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "clipper",
        "type": "CustomClipper",
        "named": true,
        "docs": "If non-null, determines which clip to use.\n\nThe default clip, which is used if this property is null, is the\nbounding box rectangle of the widget. [ClipRect] is a more\nefficient way of obtaining that effect."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "ClipRRect": {
    "name": "ClipRRect",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that clips its child using a rounded rectangle.\n\nBy default, [ClipRRect] uses its own bounds as the base rectangle for the\nclip, but the size and location of the clip can be customized using a custom\n[clipper].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "borderRadius",
        "type": "BorderRadius",
        "named": true,
        "docs": "The border radius of the rounded corners.\n\nValues are clamped so that horizontal and vertical radii sums do not\nexceed width/height.\n\nThis value is ignored if [clipper] is non-null."
      },
      {
        "name": "clipper",
        "type": "CustomClipper",
        "named": true,
        "docs": "If non-null, determines which clip to use."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "ClipRect": {
    "name": "ClipRect",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that clips its child using a rectangle.\n\nBy default, [ClipRect] prevents its child from painting outside its\nbounds, but the size and location of the clip rect can be customized using a\ncustom [clipper].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "clipper",
        "type": "CustomClipper",
        "named": true,
        "docs": "If non-null, determines which clip to use."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Column": {
    "name": "Column",
    "package": "widgets",
    "parent": "Flex",
    "docs": "A widget that displays its children in a vertical array.\n\nTo cause a child to expand to fill the available vertical space, wrap the\nchild in an [Expanded] widget.\n\nThe [Column] widget does not scroll (and in general it is considered an error\nto have more children in a [Column] than will fit in the available room). If\nyou have a line of widgets and want them to be able to scroll if there is\ninsufficient room, consider using a [ScrollList].\n\nFor a horizontal variant, see [Row].\n\nIf you only have one child, then consider using [Align] or [Center] to\nposition the child.\n\n## Layout algorithm\n\nLayout for a [Column] proceeds in six steps:\n\n1. Layout each child a null or zero flex factor (e.g., those that are not\n[Expanded]) with unbounded vertical constraints and the incoming\nhorizontal constraints. If the [crossAxisAlignment] is\n[CrossAxisAlignment.stretch], instead use tight horizontal constraints\nthat match the incoming max width.\n2. Divide the remaining vertical space among the children with non-zero\nflex factors (e.g., those that are [Expanded]) according to their flex\nfactor. For example, a child with a flex factor of 2.0 will receive twice\nthe amount of vertical space as a child with a flex factor of 1.0.\n3. Layout each of the remaining children with the same horizontal\nconstraints as in step 1, but instead of using unbounded vertical\nconstraints, use vertical constraints based on the amount of space\nallocated in step 2. Children with [Flexible.fit] properties that are\n[FlexFit.tight] are given tight constraints (i.e., forced to fill the\nallocated space), and children with [Flexible.fit] properties that are\n[FlexFit.loose] are given loose constraints (i.e., not forced to fill the\nallocated space).\n4. The width of the [Column] is the maximum width of the children (which\nwill always satisfy the incoming horizontal constraints).\n5. The height of the [Column] is determined by the [mainAxisSize] property.\nIf the [mainAxisSize] property is [MainAxisSize.max], then the height of\nthe [Column] is the max height of the incoming constraints. If the\n[mainAxisSize] property is [MainAxisSize.min], then the height of the\n[Column] is the sum of heights of the children (subject to the incoming\nconstraints).\n6. Determine the position for each child according to the\n[mainAxisAlignment] and the [crossAxisAlignment]. For example, if the\n[mainAxisAlignment] is [MainAxisAlignment.spaceBetween], any vertical\nspace that has not been allocated to children is divided evenly and\nplaced between the children.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "mainAxisAlignment",
        "type": "MainAxisAlignment",
        "named": true
      },
      {
        "name": "mainAxisSize",
        "type": "MainAxisSize",
        "named": true
      },
      {
        "name": "crossAxisAlignment",
        "type": "CrossAxisAlignment",
        "named": true
      },
      {
        "name": "textBaseline",
        "type": "dynamic",
        "named": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "ConstrainedBox": {
    "name": "ConstrainedBox",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that imposes additional constraints on its child.\n\nFor example, if you wanted [child] to have a minimum height of 50.0 logical\npixels, you could use `const BoxConstraints(minHeight: 50.0)`` as the\n[constraints].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "constraints",
        "type": "BoxConstraints",
        "named": true,
        "required": true,
        "docs": "The additional constraints to impose on the child."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Container": {
    "name": "Container",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A convenience widget that combines common painting, positioning, and sizing\nwidgets.\n\nA container first surrounds the child with [padding] (inflated by any\nborders present in the [decoration]) and then applies additional\n[constraints] to the padded extent (incorporating the [width] and [height]\nas constraints, if either is non-null). The container is then surrounded by\nadditional empty space described from the [margin].\n\nDuring painting, the container first applies the given [transform], then\npaints the [decoration] to fill the padded extent, then it paints the child,\nand finally paints the [foregroundDecoration], also filling the padded\nextent.\n\nContainers with no children try to be as big as possible unless the incoming\nconstraints are unbounded, in which case they try to be as small as\npossible. Containers with children size themselves to their children. The\n`width`, `height`, and [constraints] arguments to the constructor override\nthis.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "Align the [child] within the container.\n\nIf non-null, the container will expand to fill its parent and position its\nchild within itself according to the given value. If the incoming\nconstraints are unbounded, then the child will be shrink-wrapped instead.\n\nIgnored if [child] is null."
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "Empty space to inscribe inside the [decoration]. The [child], if any, is\nplaced inside this padding."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true
      },
      {
        "name": "decoration",
        "type": "Decoration",
        "named": true
      },
      {
        "name": "foregroundDecoration",
        "type": "Decoration",
        "named": true,
        "docs": "The decoration to paint in front of the [child]."
      },
      {
        "name": "width",
        "type": "double",
        "named": true
      },
      {
        "name": "height",
        "type": "double",
        "named": true
      },
      {
        "name": "constraints",
        "type": "BoxConstraints",
        "named": true
      },
      {
        "name": "margin",
        "type": "EdgeInsets",
        "named": true,
        "docs": "Empty space to surround the [decoration] and [child]."
      },
      {
        "name": "transform",
        "type": "Matrix4",
        "named": true,
        "docs": "The transformation matrix to apply before painting the container."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The [child] contained by the container.\n\nIf null, and if the [constraints] are unbounded or also null, the\ncontainer will expand to fill all available space in its parent, unless\nthe parent provides unbounded constraints, in which case the container\nwill attempt to be as small as possible."
      }
    ]
  },
  "CupertinoActivityIndicator": {
    "name": "CupertinoActivityIndicator",
    "package": "cupertino",
    "parent": "StatefulWidget",
    "docs": "An iOS-style activity indicator.\n\nSee also:\n\n* <https://developer.apple.com/ios/human-interface-guidelines/ui-controls/progress-indicators/#activity-indicators>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "animating",
        "type": "bool",
        "named": true,
        "docs": "Whether the activity indicator is running its animation.\n\nDefaults to true."
      }
    ]
  },
  "CupertinoAlertDialog": {
    "name": "CupertinoAlertDialog",
    "package": "cupertino",
    "parent": "StatelessWidget",
    "docs": "An iOS-style alert dialog.\n\nAn alert dialog informs the user about situations that require\nacknowledgement. An alert dialog has an optional title and an optional list\nof actions. The title is displayed above the content and the actions are\ndisplayed below the content.\n\nTypically passed as the child widget to [showDialog], which displays the\ndialog.\n\nSee also:\n\n* [CupertinoDialog], which is a generic iOS-style dialog.\n* <https://developer.apple.com/ios/human-interface-guidelines/ui-views/alerts/>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "docs": "The (optional) title of the dialog is displayed in a large font at the top\nof the dialog.\n\nTypically a [Text] widget."
      },
      {
        "name": "content",
        "type": "Widget",
        "named": true,
        "docs": "The (optional) content of the dialog is displayed in the center of the\ndialog in a lighter font.\n\nTypically a [Text] widget."
      },
      {
        "name": "actions",
        "type": "List",
        "named": true,
        "docs": "The (optional) set of actions that are displayed at the bottom of the\ndialog.\n\nTypically this is a list of [CupertinoDialogAction] widgets."
      }
    ]
  },
  "CupertinoDialog": {
    "name": "CupertinoDialog",
    "package": "cupertino",
    "parent": "StatelessWidget",
    "docs": "An iOS-style dialog.\n\nThis dialog widget does not have any opinion about the contents of the\ndialog. Rather than using this widget directly, consider using\n[CupertinoAlertDialog], which implement a specific kind of dialog.\n\nSee also:\n\n* [CupertinoAlertDialog], which is a dialog with title, contents, and\nactions.\n* <https://developer.apple.com/ios/human-interface-guidelines/ui-views/alerts/>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "CupertinoDialogAction": {
    "name": "CupertinoDialogAction",
    "package": "cupertino",
    "parent": "StatelessWidget",
    "docs": "A button typically used in a [CupertinoAlertDialog].\n\nSee also:\n\n* [CupertinoAlertDialog]",
    "properties": [
      {
        "name": "onPressed",
        "type": "dynamic",
        "named": true,
        "docs": "The callback that is called when the button is tapped or otherwise activated.\n\nIf this is set to null, the button will be disabled."
      },
      {
        "name": "isDestructive",
        "type": "bool",
        "named": true,
        "docs": "Whether this action destroys an object.\n\nFor example, an action that deletes an email is destructive."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree.\n\nTypically a [Text] widget."
      }
    ]
  },
  "CupertinoSlider": {
    "name": "CupertinoSlider",
    "package": "cupertino",
    "parent": "StatefulWidget",
    "docs": "An iOS-style slider.\n\nUsed to select from a range of values.\n\nA slider can be used to select from either a continuous or a discrete set of\nvalues. The default is use a continuous range of values from [min] to [max].\nTo use discrete values, use a non-null value for [divisions], which\nindicates the number of discrete intervals. For example, if [min] is 0.0 and\n[max] is 50.0 and [divisions] is 5, then the slider can take on the values\ndiscrete values 0.0, 10.0, 20.0, 30.0, 40.0, and 50.0.\n\nThe slider itself does not maintain any state. Instead, when the state of\nthe slider changes, the widget calls the [onChanged] callback. Most widgets\nthat use a slider will listen for the [onChanged] callback and rebuild the\nslider with a new [value] to update the visual appearance of the slider.\n\nSee also:\n\n* <https://developer.apple.com/ios/human-interface-guidelines/ui-controls/sliders/>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "double",
        "named": true,
        "required": true,
        "docs": "The currently selected value for this slider.\n\nThe slider's thumb is drawn at a position that corresponds to this value."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the user selects a new value for the slider.\n\nThe slider passes the new value to the callback but does not actually\nchange state until the parent widget rebuilds the slider with the new\nvalue.\n\nIf null, the slider will be displayed as disabled.\n\nThe callback provided to onChanged should update the state of the parent\n[StatefulWidget] using the [State.setState] method, so that the parent\ngets rebuilt; for example:\n\n```dart\nnew CupertinoSlider(\nvalue: _duelCommandment.toDouble(),\nmin: 1.0,\nmax: 10.0,\ndivisions: 10,\nonChanged: (double newValue) {\nsetState(() {\n_duelCommandment = newValue.round();\n});\n},\n),\n```"
      },
      {
        "name": "min",
        "type": "double",
        "named": true,
        "docs": "The minimum value the user can select.\n\nDefaults to 0.0."
      },
      {
        "name": "max",
        "type": "double",
        "named": true,
        "docs": "The maximum value the user can select.\n\nDefaults to 1.0."
      },
      {
        "name": "divisions",
        "type": "int",
        "named": true,
        "docs": "The number of discrete divisions.\n\nTypically used with [label] to show the current discrete value.\n\nIf null, the slider is continuous."
      },
      {
        "name": "activeColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use for the portion of the slider that has been selected."
      }
    ]
  },
  "CupertinoSwitch": {
    "name": "CupertinoSwitch",
    "package": "cupertino",
    "parent": "StatefulWidget",
    "docs": "An iOS-style switch.\n\nUsed to toggle the on/off state of a single setting.\n\nThe switch itself does not maintain any state. Instead, when the state of\nthe switch changes, the widget calls the [onChanged] callback. Most widgets\nthat use a switch will listen for the [onChanged] callback and rebuild the\nswitch with a new [value] to update the visual appearance of the switch.\n\nSee also:\n\n* <https://developer.apple.com/ios/human-interface-guidelines/ui-controls/switches/>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "bool",
        "named": true,
        "required": true,
        "docs": "Whether this switch is on or off."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the user toggles with switch on or off.\n\nThe switch passes the new value to the callback but does not actually\nchange state until the parent widget rebuilds the switch with the new\nvalue.\n\nIf null, the switch will be displayed as disabled.\n\nThe callback provided to onChanged should update the state of the parent\n[StatefulWidget] using the [State.setState] method, so that the parent\ngets rebuilt; for example:\n\n```dart\nnew CupertinoSwitch(\nvalue: _giveVerse,\nonChanged: (bool newValue) {\nsetState(() {\n_giveVerse = newValue;\n});\n},\n),\n```"
      },
      {
        "name": "activeColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use when this switch is on."
      }
    ]
  },
  "CustomMultiChildLayout": {
    "name": "CustomMultiChildLayout",
    "package": "widgets",
    "parent": "MultiChildRenderObjectWidget",
    "docs": "A widget that uses a delegate to size and position multiple children.\n\nThe delegate can determine the layout constraints for each child and can\ndecide where to position each child. The delegate can also determine the\nsize of the parent, but the size of the parent cannot depend on the sizes of\nthe children.\n\n[CustomMultiChildLayout] is appropriate when there are complex relationships\nbetween the size and positioning of a multiple widgets. To control the\nlayout of a single child, [CustomSingleChildLayout] is more appropriate. For\nsimple cases, such as aligning a widget to one or another edge, the [Stack]\nwidget is more appropriate.\n\nEach child must be wrapped in a [LayoutId] widget to identify the widget for\nthe delegate.\n\nSee also:\n\n* [MultiChildLayoutDelegate], for details about how to control the layout of\nthe children.\n* [CustomSingleChildLayout], which uses a delegate to control the layout of\na single child.\n* [Stack], which arranges children relative to the edges of the container.\n* [Flow], which provides paint-time control of its children using transform\nmatrices.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "delegate",
        "type": "MultiChildLayoutDelegate",
        "named": true,
        "required": true,
        "docs": "The delegate that controls the layout of the children."
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "CustomPaint": {
    "name": "CustomPaint",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that provides a canvas on which to draw during the paint phase.\n\nWhen asked to paint, [CustomPaint] first asks its [painter] to paint on the\ncurrent canvas, then it paints its child, and then, after painting its\nchild, it asks its [foregroundPainter] to paint. The coodinate system of the\ncanvas matches the coordinate system of the [CustomPaint] object. The\npainters are expected to paint within a rectangle starting at the origin and\nencompassing a region of the given size. (If the painters paint outside\nthose bounds, there might be insufficient memory allocated to rasterize the\npainting commands and the resulting behavior is undefined.)\n\nPainters are implemented by subclassing [CustomPainter].\n\nBecause custom paint calls its painters during paint, you cannot call\n`setState` or `markNeedsLayout` during the callback (the layout for this\nframe has already happened).\n\nCustom painters normally size themselves to their child. If they do not have\na child, they attempt to size themselves to the [size], which defaults to\n[Size.zero].\n\nSee also:\n\n* [CustomPainter].\n* [Canvas].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "painter",
        "type": "CustomPainter",
        "named": true,
        "docs": "The painter that paints before the children."
      },
      {
        "name": "foregroundPainter",
        "type": "CustomPainter",
        "named": true,
        "docs": "The painter that paints after the children."
      },
      {
        "name": "size",
        "type": "dynamic",
        "named": true,
        "docs": "The size that this [CustomPaint] should aim for, given the layout\nconstraints, if there is no child.\n\nDefaults to [Size.zero].\n\nIf there's a child, this is ignored, and the size of the child is used\ninstead."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "CustomScrollView": {
    "name": "CustomScrollView",
    "package": "widgets",
    "parent": "ScrollView",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "scrollDirection",
        "type": "Axis",
        "named": true
      },
      {
        "name": "reverse",
        "type": "bool",
        "named": true
      },
      {
        "name": "controller",
        "type": "ScrollController",
        "named": true
      },
      {
        "name": "primary",
        "type": "bool",
        "named": true
      },
      {
        "name": "physics",
        "type": "ScrollPhysics",
        "named": true
      },
      {
        "name": "shrinkWrap",
        "type": "bool",
        "named": true
      },
      {
        "name": "slivers",
        "type": "List",
        "named": true
      }
    ]
  },
  "CustomSingleChildLayout": {
    "name": "CustomSingleChildLayout",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that defers the layout of its single child to a delegate.\n\nThe delegate can determine the layout constraints for the child and can\ndecide where to position the child. The delegate can also determine the size\nof the parent, but the size of the parent cannot depend on the size of the\nchild.\n\nSee also:\n\n* [SingleChildLayoutDelegate], which controls the layout of the child.\n* [Align], which sizes itself based on its child's size and positions\nthe child according to a [FractionalOffset] value.\n* [FractionallySizedBox], which sizes its child based on a fraction of its own\nsize and positions the child according to a [FractionalOffset] value.\n* [CustomMultiChildLayout], which uses a delegate to position multiple\nchildren.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "delegate",
        "type": "SingleChildLayoutDelegate",
        "named": true,
        "required": true,
        "docs": "The delegate that controls the layout of the child."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "DataTable": {
    "name": "DataTable",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design data table.\n\nDisplaying data in a table is expensive, because to lay out the\ntable all the data must be measured twice, once to negotiate the\ndimensions to use for each column, and once to actually lay out\nthe table given the results of the negotiation.\n\nFor this reason, if you have a lot of data (say, more than a dozen\nrows with a dozen columns, though the precise limits depend on the\ntarget device), it is suggested that you use a\n[PaginatedDataTable] which automatically splits the data into\nmultiple pages.\n\nSee also:\n\n* [DataColumn], which describes a column in the data table.\n* [DataRow], which contains the data for a row in the data table.\n* [DataCell], which contains the data for a single cell in the data table.\n* [PaginatedDataTable], which shows part of the data in a data table and\nprovides controls for paging through the remainder of the data.\n* <https://material.google.com/components/data-tables.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "columns",
        "type": "List",
        "named": true
      },
      {
        "name": "sortColumnIndex",
        "type": "int",
        "named": true,
        "docs": "The current primary sort key's column.\n\nIf non-null, indicates that the indicated column is the column\nby which the data is sorted. The number must correspond to the\nindex of the relevant column in [columns].\n\nSetting this will cause the relevant column to have a sort\nindicator displayed.\n\nWhen this is null, it implies that the table's sort order does\nnot correspond to any of the columns."
      },
      {
        "name": "sortAscending",
        "type": "bool",
        "named": true,
        "docs": "Whether the column mentioned in [sortColumnIndex], if any, is sorted\nin ascending order.\n\nIf true, the order is ascending (meaning the rows with the\nsmallest values for the current sort column are first in the\ntable).\n\nIf false, the order is descending (meaning the rows with the\nsmallest values for the current sort column are last in the\ntable)."
      },
      {
        "name": "onSelectAll",
        "type": "ValueSetter",
        "named": true,
        "docs": "Invoked when the user selects or unselects every row, using the\ncheckbox in the heading row.\n\nIf this is null, then the [DataRow.onSelectChanged] callback of\nevery row in the table is invoked appropriately instead.\n\nTo control whether a particular row is selectable or not, see\n[DataRow.onSelectChanged]. This callback is only relevant if any\nrow is selectable."
      },
      {
        "name": "rows",
        "type": "List",
        "named": true,
        "docs": "The data to show in each row (excluding the row that contains\nthe column headings). Must be non-null, but may be empty."
      }
    ]
  },
  "DayPicker": {
    "name": "DayPicker",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "Displays the days of a given month and allows choosing a day.\n\nThe days are arranged in a rectangular grid with one column for each day of\nthe week.\n\nThe day picker widget is rarely used directly. Instead, consider using\n[showDatePicker], which creates a date picker dialog.\n\nSee also:\n\n* [showDatePicker].\n* <https://material.google.com/components/pickers.html#pickers-date-pickers>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "selectedDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The currently selected date.\n\nThis date is highlighted in the picker."
      },
      {
        "name": "currentDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The current date at the time the picker is displayed."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the user picks a day."
      },
      {
        "name": "firstDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The earliest date the user is permitted to pick."
      },
      {
        "name": "lastDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The latest date the user is permitted to pick."
      },
      {
        "name": "displayedMonth",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The month whose days are displayed by this picker."
      },
      {
        "name": "selectableDayPredicate",
        "type": "SelectableDayPredicate",
        "named": true,
        "docs": "Optional user supplied predicate function to customize selectable days."
      }
    ]
  },
  "DecoratedBox": {
    "name": "DecoratedBox",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that paints a [Decoration] either before or after its child paints.\n\n[Container] insets its child by the widths of the borders; this widget does\nnot.\n\nCommonly used with [BoxDecoration].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "decoration",
        "type": "Decoration",
        "named": true,
        "required": true,
        "docs": "What decoration to paint.\n\nCommonly a [BoxDecoration]."
      },
      {
        "name": "position",
        "type": "DecorationPosition",
        "named": true,
        "docs": "Whether to paint the box decoration behind or in front of the child."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "DefaultAssetBundle": {
    "name": "DefaultAssetBundle",
    "package": "widgets",
    "parent": "InheritedWidget",
    "docs": "A widget that determines the default asset bundle for its descendants.\n\nFor example, used by [Image] to determine which bundle to use for\n[AssetImage]s if no bundle is specified explicitly.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "bundle",
        "type": "AssetBundle",
        "named": true,
        "required": true,
        "docs": "The bundle to use as a default."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "DefaultTabController": {
    "name": "DefaultTabController",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "The [TabController] for descendant widgets that don't specify one explicitly.\n\nDefaultTabController is an inherited widget that is used to share a\nTabController with a [TabBar] or a [TabBarView]. It's used when\nsharing an explicitly created TabController isn't convenient because\nthe tab bar widgets are created by a stateless parent widget or by\ndifferent parent widgets.\n\n```dart\nclass MyDemo extends StatelessWidget {\nfinal List<Tab> myTabs = <Tab>[\nnew Tab(text: 'LEFT'),\nnew Tab(text: 'RIGHT'),\n];\n\n@override\nWidget build(BuildContext context) {\nreturn new DefaultTabController(\nlength: myTabs.length,\nchild: new Scaffold(\nappBar: new AppBar(\nbottom: new TabBar(\ntabs: myTabs,\n),\n),\nbody: new TabBarView(\nchildren: myTabs.map((Tab tab) {\nreturn new Center(child: new Text(tab.text));\n}).toList(),\n),\n),\n);\n}\n}\n```",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "length",
        "type": "int",
        "named": true,
        "required": true,
        "docs": "The total number of tabs. Must be greater than one."
      },
      {
        "name": "initialIndex",
        "type": "int",
        "named": true,
        "docs": "The initial index of the selected tab."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "This widget's child. Often a [Scaffold] whose [AppBar] includes a [TabBar]."
      }
    ]
  },
  "DefaultTextStyle": {
    "name": "DefaultTextStyle",
    "package": "widgets",
    "parent": "InheritedWidget",
    "docs": "The text style to apply to descendant [Text] widgets without explicit style.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "style",
        "type": "TextStyle",
        "named": true,
        "required": true,
        "docs": "The text style to apply."
      },
      {
        "name": "textAlign",
        "type": "dynamic",
        "named": true,
        "docs": "How the text should be aligned horizontally."
      },
      {
        "name": "softWrap",
        "type": "bool",
        "named": true,
        "docs": "Whether the text should break at soft line breaks.\n\nIf false, the glyphs in the text will be positioned as if there was unlimited horizontal space."
      },
      {
        "name": "overflow",
        "type": "TextOverflow",
        "named": true,
        "docs": "How visual overflow should be handled."
      },
      {
        "name": "maxLines",
        "type": "int",
        "named": true,
        "docs": "An optional maximum number of lines for the text to span, wrapping if necessary.\nIf the text exceeds the given number of lines, it will be truncated according\nto [overflow]."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "Dialog": {
    "name": "Dialog",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design dialog.\n\nThis dialog widget does not have any opinion about the contents of the\ndialog. Rather than using this widget directly, consider using [AlertDialog]\nor [SimpleDialog], which implement specific kinds of material design\ndialogs.\n\nSee also:\n\n* [AlertDialog], for dialogs that have a message and some buttons.\n* [SimpleDialog], for dialogs that offer a variety of options.\n* [showDialog], which actually displays the dialog and returns its result.\n* <https://material.google.com/components/dialogs.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "Dismissable": {
    "name": "Dismissable",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that can be dismissed by dragging in the indicated [direction].\n\nDragging or flinging this widget in the [DismissDirection] causes the child\nto slide out of view. Following the slide animation, if [resizeDuration] is\nnon-null, the Dismissable widget animates its height (or width, whichever is\nperpendicular to the dismiss direction) to zero over the [resizeDuration].\n\nBackgrounds can be used to implement the \"leave-behind\" idiom. If a background\nis specified it is stacked behind the Dismissable's child and is exposed when\nthe child moves.\n\nThe widget calls the [onDimissed] callback either after its size has\ncollapsed to zero (if [resizeDuration] is non-null) or immediately after\nthe slide animation (if [resizeDuration] is null). If the Dismissable is a\nlist item, it must have a key that distinguishes it from the other items and\nits [onDismissed] callback must remove the item from the list.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true,
        "required": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "background",
        "type": "Widget",
        "named": true,
        "docs": "A widget that is stacked behind the child. If secondaryBackground is also\nspecified then this widget only appears when the child has been dragged\ndown or to the right."
      },
      {
        "name": "secondaryBackground",
        "type": "Widget",
        "named": true,
        "docs": "A widget that is stacked behind the child and is exposed when the child\nhas been dragged up or to the left. It may only be specified when background\nhas also been specified."
      },
      {
        "name": "onResize",
        "type": "dynamic",
        "named": true,
        "docs": "Called when the widget changes size (i.e., when contracting before being dismissed)."
      },
      {
        "name": "onDismissed",
        "type": "DismissDirectionCallback",
        "named": true,
        "docs": "Called when the widget has been dismissed, after finishing resizing."
      },
      {
        "name": "direction",
        "type": "DismissDirection",
        "named": true,
        "docs": "The direction in which the widget can be dismissed."
      },
      {
        "name": "resizeDuration",
        "type": "Duration",
        "named": true,
        "docs": "The amount of time the widget will spend contracting before [onDismissed] is called.\n\nIf null, the widget will not contract and [onDismissed] will be called\nimmediately after the the widget is dismissed."
      },
      {
        "name": "dismissThresholds",
        "type": "Map",
        "named": true,
        "docs": "The offset threshold the item has to be dragged in order to be considered dismissed.\n\nRepresented as a fraction, e.g. if it is 0.4, then the item has to be dragged at least\n40% towards one direction to be considered dismissed. Clients can define different\nthresholds for each dismiss direction. This allows for use cases where item can be\ndismissed to end but not to start."
      }
    ]
  },
  "Divider": {
    "name": "Divider",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A one logical pixel thick horizontal line, with padding on either\nside.\n\nIn the material design language, this represents a divider.\n\nDividers can be used in lists, [Drawer]s, and elsewhere to separate content\nvertically. To create a one-pixel divider between items in a list, consider\nusing [ListItem.divideItems], which is optimized for this case.\n\nThe box's total height is controlled by [height]. The appropriate padding is\nautomatically computed from the height.\n\nSee also:\n\n* [PopupMenuDivider], which is the equivalent but for popup menus.\n* [ListItem.divideItems], another approach to dividing widgets in a list.\n* <https://material.google.com/components/dividers.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "The divider's vertical extent.\n\nThe divider itself is always drawn as one logical pixel thick horizontal\nline that is centered within the height specified by this value."
      },
      {
        "name": "indent",
        "type": "double",
        "named": true,
        "docs": "The amount of empty space to the left of the divider."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use when painting the line.\n\nDefaults to the current theme's divider color, given by\n[ThemeData.dividerColor].\n\n```dart\nnew Divider(\ncolor: Colors.deepOrange[500],\n),\n```"
      }
    ]
  },
  "DragTarget": {
    "name": "DragTarget",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that receives data when a [Draggable] widget is dropped.\n\nWhen a draggable is dragged on top of a drag target, the drag target is\nasked whether it will accept the data the draggable is carrying. If the user\ndoes drop the draggable on top of the drag target (and the drag target has\nindicated that it will accept the draggable's data), then the drag target is\nasked to accept the draggable's data.\n\nSee also:\n\n* [Draggable]\n* [LongPressDraggable]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "builder",
        "type": "DragTargetBuilder",
        "named": true,
        "required": true,
        "docs": "Called to build the contents of this widget.\n\nThe builder can build different widgets depending on what is being dragged\ninto this drag target."
      },
      {
        "name": "onWillAccept",
        "type": "DragTargetWillAccept",
        "named": true,
        "docs": "Called to determine whether this widget is interested in receiving a given\npiece of data being dragged over this drag target."
      },
      {
        "name": "onAccept",
        "type": "DragTargetAccept",
        "named": true,
        "docs": "Called when an acceptable piece of data was dropped over this drag target."
      }
    ]
  },
  "Draggable": {
    "name": "Draggable",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that can be dragged from to a [DragTarget].\n\nWhen a draggable widget recognizes the start of a drag gesture, it displays\na [feedback] widget that tracks the user's finger across the screen. If the\nuser lifts their finger while on top of a [DragTarget], that target is given\nthe opportunity to accept the [data] carried by the draggable.\n\nOn multitouch devices, multiple drags can occur simultaneously because there\ncan be multiple pointers in contact with the device at once. To limit the\nnumber of simultaneous drags, use the [maxSimultaneousDrags] property. The\ndefault is to allow an unlimited number of simultaneous drags.\n\nThis widget displays [child] when zero drags are under way. If\n[childWhenDragging] is non-null, this widget instead displays\n[childWhenDragging] when one or more drags are underway. Otherwise, this\nwidget always displays [child].\n\nSee also:\n\n* [DragTarget]\n* [LongPressDraggable]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree.\n\nThis widget displays [child] when zero drags are under way. If\n[childWhenDragging] is non-null, this widget instead displays\n[childWhenDragging] when one or more drags are underway. Otherwise, this\nwidget always displays [child].\n\nThe [feedback] widget is shown under the pointer when a drag is under way.\n\nTo limit the number of simultaneous drags on multitouch devices, see\n[maxSimultaneousDrags]."
      },
      {
        "name": "feedback",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget to show under the pointer when a drag is under way.\n\nSee [child] and [childWhenDragging] for information about what is shown\nat the location of the [Draggable] itself when a drag is under way."
      },
      {
        "name": "data",
        "type": "T",
        "named": true,
        "docs": "The data that will be dropped by this draggable."
      },
      {
        "name": "childWhenDragging",
        "type": "Widget",
        "named": true,
        "docs": "The widget to display instead of [child] when one or more drags are under way.\n\nIf this is null, then this widget will always display [child] (and so the\ndrag source representation will not change while a drag is under\nway).\n\nThe [feedback] widget is shown under the pointer when a drag is under way.\n\nTo limit the number of simultaneous drags on multitouch devices, see\n[maxSimultaneousDrags]."
      },
      {
        "name": "feedbackOffset",
        "type": "dynamic",
        "named": true,
        "docs": "The feedbackOffset can be used to set the hit test target point for the\npurposes of finding a drag target. It is especially useful if the feedback\nis transformed compared to the child."
      },
      {
        "name": "dragAnchor",
        "type": "DragAnchor",
        "named": true,
        "docs": "Where this widget should be anchored during a drag."
      },
      {
        "name": "affinity",
        "type": "Axis",
        "named": true,
        "docs": "Controls how this widget competes with other gestures to initiate a drag.\n\nIf affinity is null, this widget initiates a drag as soon as it recognizes\na tap down gesture, regardless of any directionality. If affinity is\nhorizontal (or vertical), then this widget will compete with other\nhorizontal (or vertical, respectively) gestures.\n\nFor example, if this widget is placed in a vertically scrolling region and\nhas horizontal affinity, pointer motion in the vertical direction will\nresult in a scroll and pointer motion in the horizontal direction will\nresult in a drag. Conversely, if the widget has a null or vertical\naffinity, pointer motion in any direction will result in a drag rather\nthan in a scroll because the draggable widget, being the more specific\nwidget, will out-compete the [Scrollable] for vertical gestures."
      },
      {
        "name": "maxSimultaneousDrags",
        "type": "int",
        "named": true,
        "docs": "How many simultaneous drags to support.\n\nWhen null, no limit is applied. Set this to 1 if you want to only allow\nthe drag source to have one item dragged at a time. Set this to 0 if you\nwant to prevent the draggable from actually being dragged.\n\nIf you set this property to 1, consider supplying an \"empty\" widget for\n[childWhenDragging] to create the illusion of actually moving [child]."
      },
      {
        "name": "onDragStarted",
        "type": "dynamic",
        "named": true,
        "docs": "Called when the draggable starts being dragged."
      },
      {
        "name": "onDraggableCanceled",
        "type": "DraggableCanceledCallback",
        "named": true,
        "docs": "Called when the draggable is dropped without being accepted by a [DragTarget].\n\nThis function might be called after this widget has been removed from the\ntree. For example, if a drag was in progress when this widget was removed\nfrom the tree and the drag ended up being canceled, this callback will\nstill be called. For this reason, implementations of this callback might\nneed to check [State.mounted] to check whether the state receiving the\ncallback is still in the tree."
      }
    ]
  },
  "Drawer": {
    "name": "Drawer",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design panel that slides in horizontally from the edge of a\n[Scaffold] to show navigation links in an application.\n\nDrawers are typically used with the [Scaffold.drawer] property. The child of\nthe drawer is usually a [ListView] whose first child is a [DrawerHeader]\nthat displays status information about the current user.\n\nThe [AppBar] automatically displays an appropriate [IconButton] to show the\n[Drawer] when a [Drawer] is available in the [Scaffold]. The [Scaffold]\nautomatically handles the edge-swipe gesture to show the drawer.\n\nSee also:\n\n* [Scaffold.drawer], where one specifies a [Drawer] so that it can be\nshown.\n* [Scaffold.of], to obtain the current [ScaffoldState], which manages the\ndisplay and animation of the drawer.\n* [ScaffoldState.openDrawer], which displays its [Drawer], if any.\n* [Navigator.pop], which closes the drawer if it is open.\n* [DrawerItem], a widget for items in drawers.\n* [DrawerHeader], a widget for the top part of a drawer.\n* <https://material.google.com/patterns/navigation-drawer.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this drawer.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 16, the appropriate elevation for drawers."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree.\n\nTypically a [SliverList]."
      }
    ]
  },
  "DrawerController": {
    "name": "DrawerController",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "Provides interactive behavior for [Drawer] widgets.\n\nRarely used directly. Drawer controllers are typically created automatically\nby [Scaffold] widgets.\n\nThe draw controller provides the ability to open and close a drawer, either\nvia an animation or via user interaction. When closed, the drawer collapses\nto a translucent gesture detector that can be used to listen for edge\nswipes.\n\nSee also:\n\n* [Drawer]\n* [Scaffold.drawer]",
    "properties": [
      {
        "name": "key",
        "type": "GlobalKey",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree.\n\nTypically a [Drawer]."
      }
    ]
  },
  "DrawerHeader": {
    "name": "DrawerHeader",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "The top-most region of a material design drawer. The header's [child]\nwidget, if any, is placed inside a [Container] whose [decoration] can be\npassed as an argument, inset by the given [padding].\n\nPart of the material design [Drawer].\n\nRequires one of its ancestors to be a [Material] widget. This condition is\nsatisfied by putting the [DrawerItem] in a [Drawer].\n\nSee also:\n\n* [Drawer]\n* [UserAccountsDrawerHeader], a variant of [DrawerHeader] that is\nspecialized for showing user accounts.\n* [DrawerItem]\n* <https://material.google.com/patterns/navigation-drawer.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "decoration",
        "type": "Decoration",
        "named": true,
        "docs": "Decoration for the main drawer header [Container]; useful for applying\nbackgrounds.\n\nThis decoration will extend under the system status bar.\n\nIf this is changed, it will be animated according to [duration] and [curve]."
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "The padding by which to inset [child].\n\nThe [DrawerHeader] additionally offsets the child by the height of the\nsystem status bar.\n\nIf the child is null, the padding has no effect."
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "docs": "The duration for animations of the [decoration]."
      },
      {
        "name": "curve",
        "type": "Curve",
        "named": true,
        "docs": "The curve for animations of the [decoration]."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "A widget to be placed inside the drawer header, inset by the [padding].\n\nThis widget will be sized to the size of the header. To position the child\nprecisely, consider using an [Align] or [Center] widget."
      }
    ]
  },
  "DrawerItem": {
    "name": "DrawerItem",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "An item in a material design drawer.\n\nPart of the material design [Drawer].\n\nRequires one of its ancestors to be a [Material] widget. This condition is\nsatisfied by putting the [DrawerItem] in a [Drawer].\n\nSee also:\n\n* [Drawer]\n* [DrawerHeader]\n* <https://material.google.com/patterns/navigation-drawer.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "icon",
        "type": "Widget",
        "named": true,
        "docs": "The icon to display before the child widget.\n\nThe size and color of the icon is configured automatically using an\n[IconTheme] and therefore do not need to be explicitly given in the\nicon widget.\n\nSee [Icon], [ImageIcon]."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "onPressed",
        "type": "dynamic",
        "named": true,
        "docs": "Called when the user taps this drawer item.\n\nIf null, the drawer item is displayed as disabled.\n\nTo close the [Drawer] when an item is pressed, call [Navigator.pop]."
      },
      {
        "name": "selected",
        "type": "bool",
        "named": true,
        "docs": "Whether this drawer item is currently selected.\n\nThe currently selected item is highlighted to distinguish it from other\ndrawer items."
      }
    ]
  },
  "DropdownButton": {
    "name": "DropdownButton",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design button for selecting from a list of items.\n\nA dropdown button lets the user select from a number of items. The button\nshows the currently selected item as well as an arrow that opens a menu for\nselecting another item.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [DropdownButtonHideUnderline], which prevents its descendant dropdown buttons\nfrom displaying their underlines.\n* [RaisedButton], [FlatButton], ordinary buttons that trigger a single action.\n* <https://material.google.com/components/buttons.html#buttons-dropdown-buttons>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "items",
        "type": "List",
        "named": true,
        "required": true,
        "docs": "The list of possible items to select among."
      },
      {
        "name": "value",
        "type": "T",
        "named": true,
        "docs": "The currently selected item, or null if no item has been selected. If\nvalue is null then the menu is popped up as if the first item was\nselected."
      },
      {
        "name": "hint",
        "type": "Widget",
        "named": true,
        "docs": "Displayed if [value] is null."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the user selects an item."
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place the menu when open.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 8, the appropriate elevation for dropdown buttons."
      },
      {
        "name": "style",
        "type": "TextStyle",
        "named": true,
        "docs": "The text style to use for text in the dropdown button and the dropdown\nmenu that appears when you tap the button.\n\nDefaults to the [TextTheme.subhead] value of the current\n[ThemeData.textTheme] of the current [Theme]."
      },
      {
        "name": "iconSize",
        "type": "double",
        "named": true,
        "docs": "The size to use for the drop-down button's down arrow icon button.\n\nDefaults to 24.0."
      },
      {
        "name": "isDense",
        "type": "bool",
        "named": true,
        "docs": "Reduce the button's height.\n\nBy default this button's height is the same as its menu items' heights.\nIf isDense is true, the button's height is reduced by about half. This\ncan be useful when the button is embedded in a container that adds\nits own decorations, like [InputContainer]."
      }
    ]
  },
  "DropdownButtonHideUnderline": {
    "name": "DropdownButtonHideUnderline",
    "package": "material",
    "parent": "InheritedWidget",
    "docs": "An inherited widget that causes any descendant [DropdownButton]\nwidgets to not include their regular underline.\n\nThis is used by [DataTable] to remove the underline from any\n[DropdownButton] widgets placed within material data tables, as\nrequired by the material design specification.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "DropdownMenuItem": {
    "name": "DropdownMenuItem",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "An item in a menu created by a [DropdownButton].\n\nThe type `T` is the type of the value the entry represents. All the entries\nin a given menu must represent values with consistent types.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "T",
        "named": true,
        "docs": "The value to return if the user selects this menu item.\n\nEventually returned in a call to [DropdownButton.onChanged]."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree.\n\nTypically a [Text] widget."
      }
    ]
  },
  "EditableText": {
    "name": "EditableText",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A basic text input field.\n\nThis widget interacts with the [TextInput] service to let the user edit the\ntext it contains. It also provides scrolling, selection, and cursor\nmovement. This widget does not provide any focus management (e.g.,\ntap-to-focus).\n\nRather than using this widget directly, consider using [InputField], which\nadds tap-to-focus and cut, copy, and paste commands, or [TextField], which\nis a full-featured, material-design text input field with placeholder text,\nlabels, and [Form] integration.\n\nSee also:\n\n* [InputField], which adds tap-to-focus and cut, copy, and paste commands.\n* [TextField], which is a full-featured, material-design text input field\nwith placeholder text, labels, and [Form] integration.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "InputValue",
        "named": true,
        "required": true,
        "docs": "The string being displayed in this widget."
      },
      {
        "name": "focusKey",
        "type": "GlobalKey",
        "named": true,
        "required": true,
        "docs": "Key of the enclosing widget that holds the focus."
      },
      {
        "name": "obscureText",
        "type": "bool",
        "named": true,
        "docs": "Whether to hide the text being edited (e.g., for passwords).\n\nDefaults to false."
      },
      {
        "name": "style",
        "type": "TextStyle",
        "named": true,
        "required": true,
        "docs": "The text style to use for the editable text."
      },
      {
        "name": "cursorColor",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The color to use when painting the cursor."
      },
      {
        "name": "textScaleFactor",
        "type": "double",
        "named": true,
        "docs": "The number of font pixels for each logical pixel.\n\nFor example, if the text scale factor is 1.5, text will be 50% larger than\nthe specified font size.\n\nDefaults to [MediaQuery.textScaleFactor]."
      },
      {
        "name": "maxLines",
        "type": "int",
        "named": true,
        "docs": "The maximum number of lines for the text to span, wrapping if necessary.\nIf this is 1 (the default), the text will not wrap, but will scroll\nhorizontally instead."
      },
      {
        "name": "autofocus",
        "type": "bool",
        "named": true,
        "docs": "Whether this input field should focus itself if nothing else is already focused.\nIf true, the keyboard will open as soon as this input obtains focus. Otherwise,\nthe keyboard is only shown after the user taps the text field.\n\nDefaults to false."
      },
      {
        "name": "selectionColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use when painting the selection."
      },
      {
        "name": "selectionControls",
        "type": "TextSelectionControls",
        "named": true,
        "docs": "Optional delegate for building the text selection handles and toolbar."
      },
      {
        "name": "keyboardType",
        "type": "TextInputType",
        "named": true,
        "docs": "The type of keyboard to use for editing the text."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "docs": "Called when the text being edited changes."
      },
      {
        "name": "onSubmitted",
        "type": "ValueChanged",
        "named": true,
        "docs": "Called when the user indicates that they are done editing the text in the field."
      }
    ]
  },
  "ErrorWidget": {
    "name": "ErrorWidget",
    "package": "widgets",
    "parent": "LeafRenderObjectWidget",
    "docs": "A widget that renders an exception's message.\n\nThis widget is used when a build function fails, to help with determining\nwhere the problem lies. Exceptions are also logged to the console, which you\ncan read using `flutter logs`. The console will also include additional\ninformation such as the stack trace for the exception.",
    "properties": [
      {
        "name": "exception",
        "type": "Object",
        "required": true
      }
    ]
  },
  "ExcludeSemantics": {
    "name": "ExcludeSemantics",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that drops all the semantics of its descendants.\n\nThis can be used to hide subwidgets that would otherwise be\nreported but that would only be confusing. For example, the\nmaterial library's [Chip] widget hides the avatar since it is\nredundant with the chip label.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "ExpandIcon": {
    "name": "ExpandIcon",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A widget representing a rotating expand/collapse button. The icon rotates\n180 deg when pressed, then reverts the animation on a second press.\nThe underlying icon is [Icons.expand_more].\n\nSee [IconButton] for a more general implementation of a pressable button\nwith an icon.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "isExpanded",
        "type": "bool",
        "named": true,
        "docs": "Whether the icon is in an expanded state.\n\nRebuilding the widget with a different [isExpanded] value will trigger\nthe animation, but will not trigger the [onPressed] callback."
      },
      {
        "name": "size",
        "type": "double",
        "named": true,
        "docs": "The size of the icon.\n\nThis property must not be null. It defaults to 24.0."
      },
      {
        "name": "onPressed",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "The callback triggered when the icon is pressed and the state changes\nbetween expanded and collapsed. The value passed to the current state.\n\nIf this is set to null, the button will be disabled."
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "The padding around the icon. The entire padded icon will reactb to input\ngestures.\n\nThis property must not be null. It defaults to 8.0 padding on all sides."
      }
    ]
  },
  "Expanded": {
    "name": "Expanded",
    "package": "widgets",
    "parent": "Flexible",
    "docs": "A widget that expands a child of a [Row], [Column], or [Flex].\n\nUsing an [Expanded] widget makes a child of a [Row], [Column], or [Flex]\nexpand to fill the available space in the main axis (e.g., horizontally for\na [Row] or vertically for a [Column]). If multiple children are expanded,\nthe available space is divided amoung them according to the [flex] factor.\n\nAn [Expanded] widget must be a descendant of a [Row], [Column], or [Flex],\nand the path from the [Expanded] widget to its enclosing [Row], [Column], or\n[Flex] must contain only [StatelessWidget]s or [StatefulWidget]s (not other\nkinds of widgets, like [RenderObjectWidget]s).\n\nSee also:\n\n* [Flexible], which does not force the child to fill the available space.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "flex",
        "type": "int",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "ExpansionPanelList": {
    "name": "ExpansionPanelList",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material expansion panel list that lays out its children and animates\nexpansions.\n\nSee also:\n\n* [ExpansionPanel]\n* <https://material.google.com/components/expansion-panels.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true,
        "docs": "The children of the expansion panel list. They are layed in a similar\nfashion to [BlockBody]."
      },
      {
        "name": "expansionCallback",
        "type": "ExpansionPanelCallback",
        "named": true,
        "docs": "The callback that gets called whenever one of the expand/collapse buttons\nis pressed. The arguments passed to the callback are the index of the\nto-be-expanded panel in the list and whether the panel is currently\nexpanded or not.\n\nThis callback is useful in order to keep track of the expanded/collapsed\npanels in a parent widget that may need to react to these changes."
      },
      {
        "name": "animationDuration",
        "type": "Duration",
        "named": true,
        "docs": "The duration of the expansion animation."
      }
    ]
  },
  "FadeTransition": {
    "name": "FadeTransition",
    "package": "widgets",
    "parent": "AnimatedWidget",
    "docs": "Animates the opacity of a widget.\n\nFor a widget that automatically animates between the sizes of two children,\nfading between them, see [AnimatedCrossFade].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "opacity",
        "type": "Animation",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "FittedBox": {
    "name": "FittedBox",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "Scales and positions its child within itself according to [fit].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "fit",
        "type": "ImageFit",
        "named": true,
        "docs": "How to inscribe the child into the space allocated during layout."
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "How to align the child within its parent's bounds.\n\nAn alignment of (0.0, 0.0) aligns the child to the top-left corner of its\nparent's bounds.  An alignment of (1.0, 0.5) aligns the child to the middle\nof the right edge of its parent's bounds."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "FlatButton": {
    "name": "FlatButton",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design \"flat button\".\n\nA flat button is a section printed on a [Material] widget that reacts to\ntouches by filling with color.\n\nUse flat buttons on toolbars, in dialogs, or inline with other content but\noffset from that content with padding so that the button's presence is\nobvious. Flat buttons intentionally do not have visible borders and must\ntherefore rely on their position relative to other content for context. In\ndialogs and cards, they should be grouped together in one of the bottom\ncorners. Avoid using flat buttons where they would blend in with other\ncontent, for example in the middle of lists.\n\nMaterial design flat buttons have an all-caps label, some internal padding,\nand some defined dimensions. To have a part of your application be\ninteractive, with ink splashes, without also committing to these stylistic\nchoices, consider using [InkWell] instead.\n\nIf the [onPressed] callback is null, then the button will be disabled,\nwill not react to touch, and will be colored as specified by\nthe [disabledColor] property instead of the [color] property. If you are\ntrying to change the button's [color] and it is not having any effect, check\nthat you are passing a non-null [onPressed] handler.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [RaisedButton], which is a button that hovers above the containing\nmaterial.\n* [DropdownButton], which offers the user a choice of a number of options.\n* [SimpleDialogOption], which is used in [SimpleDialog]s.\n* [InkWell], which implements the ink splash part of a flat button.\n* <https://material.google.com/components/buttons.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "onPressed",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The callback that is called when the button is tapped or otherwise activated.\n\nIf this is set to null, the button will be disabled."
      },
      {
        "name": "textColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use for this button's text.\n\nDefaults to the color determined by the [textTheme]."
      },
      {
        "name": "disabledTextColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use for this button's text when the button cannot be pressed.\n\nDefaults to a color derived from the [Theme]."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color of the button, as printed on the [Material]. Defaults to null,\nmeaning that the color is automatically derived from the [Theme].\n\nTypically, a material design color will be used, as follows:\n\n```dart\nnew FlatButton(\ncolor: Colors.blue[500],\nonPressed: _handleTap,\nchild: new Text('DEMO'),\n),\n```"
      },
      {
        "name": "disabledColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color of the button when the button is disabled. Buttons are disabled\nby default. To enable a button, set its [onPressed] property to a non-null\nvalue."
      },
      {
        "name": "textTheme",
        "type": "ButtonTextTheme",
        "named": true,
        "docs": "The color scheme to use for this button's text.\n\nDefaults to the button color from [ButtonTheme]."
      },
      {
        "name": "colorBrightness",
        "type": "Brightness",
        "named": true,
        "docs": "The theme brightness to use for this button.\n\nDefaults to the brightness from [ThemeData.brightness]."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree.\n\nTypically a [Text] widget in all caps."
      }
    ]
  },
  "Flex": {
    "name": "Flex",
    "package": "widgets",
    "parent": "MultiChildRenderObjectWidget",
    "docs": "A widget that displays its children in a one-dimensional array.\n\nThe [Flex] widget allows you to control the axis along which the children are\nplaced (horizontal or vertical). This is referred to as the _main axis_. If\nyou know the main axis in advance, then consider using a [Row] (if it's\nhorizontal) or [Column] (if it's vertical) instead, because that will be less\nverbose.\n\nTo cause a child to expand to fill the available vertical space, wrap the\nchild in an [Expanded] widget.\n\nThe [Flex] widget does not scroll (and in general it is considered an error\nto have more children in a [Flex] than will fit in the available room). If\nyou have some widgets and want them to be able to scroll if there is\ninsufficient room, consider using a [ScrollList].\n\nIf you only have one child, then rather than using [Flex], [Row], or\n[Column], consider using [Align] or [Center] to position the child.\n\n## Layout algorithm\n\nLayout for a [Flex] proceeds in six steps:\n\n1. Layout each child a null or zero flex factor (e.g., those that are not\n[Expanded]) with unbounded main axis constraints and the incoming\ncross axis constraints. If the [crossAxisAlignment] is\n[CrossAxisAlignment.stretch], instead use tight cross axis constraints\nthat match the incoming max extent in the cross axis.\n2. Divide the remaining main axis space among the children with non-zero\nflex factors (e.g., those that are [Expanded]) according to their flex\nfactor. For example, a child with a flex factor of 2.0 will receive twice\nthe amount of main axis space as a child with a flex factor of 1.0.\n3. Layout each of the remaining children with the same cross axis\nconstraints as in step 1, but instead of using unbounded main axis\nconstraints, use max axis constraints based on the amount of space\nallocated in step 2. Children with [Flexible.fit] properties that are\n[FlexFit.tight] are given tight constraints (i.e., forced to fill the\nallocated space), and children with [Flexible.fit] properties that are\n[FlexFit.loose] are given loose constraints (i.e., not forced to fill the\nallocated space).\n4. The cross axis extent of the [Flex] is the maximum cross axis extent of\nthe children (which will always satisfy the incoming constraints).\n5. The main axis extent of the [Flex] is determined by the [mainAxisSize]\nproperty. If the [mainAxisSize] property is [MainAxisSize.max], then the\nmain axis extent of the [Flex] is the max extent of the incoming main\naxis constraints. If the [mainAxisSize] property is [MainAxisSize.min],\nthen the main axis extent of the [Flex] is the sum of the main axis\nextents of the children (subject to the incoming constraints).\n6. Determine the position for each child according to the\n[mainAxisAlignment] and the [crossAxisAlignment]. For example, if the\n[mainAxisAlignment] is [MainAxisAlignment.spaceBetween], any main axis\nspace that has not been allocated to children is divided evenly and\nplaced between the children.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "direction",
        "type": "Axis",
        "named": true,
        "required": true,
        "docs": "The direction to use as the main axis.\n\nIf you know the axis in advance, then consider using a [Row] (if it's\nhorizontal) or [Column] (if it's vertical) instead of a [Flex], since that\nwill be less verbose. (For [Row] and [Column] this property is fixed to\nthe appropriate axis.)"
      },
      {
        "name": "mainAxisAlignment",
        "type": "MainAxisAlignment",
        "named": true,
        "docs": "How the children should be placed along the main axis.\n\nFor example, [MainAxisAlignment.start], the default, places the children\nat the start (i.e., the left for a [Row] or the top for a [Column]) of the\nmain axis."
      },
      {
        "name": "mainAxisSize",
        "type": "MainAxisSize",
        "named": true,
        "docs": "How much space space should be occupied in the main axis.\n\nAfter allocating space to children, there might be some remaining free\nspace. This value controls whether to maximize or minimize the amount of\nfree space, subject to the incoming layout constraints.\n\nIf some children have a non-zero flex factors (and none have a fit of\n[FlexFit.loose]), they will expand to consume all the available space and\nthere will be no remaining free space to maximize or minimize, making this\nvalue irrelevant to the final layout."
      },
      {
        "name": "crossAxisAlignment",
        "type": "CrossAxisAlignment",
        "named": true,
        "docs": "How the children should be placed along the cross axis.\n\nFor example, [CrossAxisAlignment.center], the default, centers the\nchildren in the cross axis (e.g., horizontally for a [Column])."
      },
      {
        "name": "textBaseline",
        "type": "dynamic",
        "named": true,
        "docs": "If aligning items according to their baseline, which baseline to use."
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "Flexible": {
    "name": "Flexible",
    "package": "widgets",
    "parent": "ParentDataWidget",
    "docs": "A widget that controls how a child of a [Row], [Column], or [Flex] flexes.\n\nUsing a [Flexible] widget gives a child of a [Row], [Column], or [Flex]\nthe flexibility to expand to fill the available space in the main axis\n(e.g., horizontally for a [Row] or vertically for a [Column]), but, unlike\n[Expanded], [Flexible] does not require the child to fill the available\nspace.\n\nA [Flexible] widget must be a descendant of a [Row], [Column], or [Flex],\nand the path from the [Flexible] widget to its enclosing [Row], [Column], or\n[Flex] must contain only [StatelessWidget]s or [StatefulWidget]s (not other\nkinds of widgets, like [RenderObjectWidget]s).\n\nSee also:\n\n* [Expanded], which forces the child to expand to fill the available space.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "flex",
        "type": "int",
        "named": true,
        "docs": "The flex factor to use for this child\n\nIf null or zero, the child is inflexible and determines its own size. If\nnon-zero, the amount of space the child's can occupy in the main axis is\ndetermined by dividing the free space (after placing the inflexible\nchildren) according to the flex factors of the flexible children."
      },
      {
        "name": "fit",
        "type": "FlexFit",
        "named": true,
        "docs": "How a flexible child is inscribed into the available space.\n\nIf [flex] is non-zero, the [fit] determines whether the child fills the\nspace the parent makes available during layout. If the fit is\n[FlexFit.tight], the child is required to fill the available space. If the\nfit is [FlexFit.loose], the child can be at most as large as the available\nspace (but is allowed to be smaller)."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "FlexibleSpaceBar": {
    "name": "FlexibleSpaceBar",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "The part of a material design [AppBar] that expands and collapses.\n\nMost commonly used in in the [SliverAppBar.flexibleSpace] field, a flexible\nspace bar expands and contracts as the app scrolls so that the [AppBar]\nreaches from the top of the app to the top of the scrolling contents of the\napp.\n\nThe widget that sizes the [AppBar] must wrap it in the widget returned by\n[FlexibleSpaceBar.createSettings], to convey sizing information down to the\n[FlexibleSpaceBar].\n\nSee also:\n\n* [SliverAppBar], which implements the expanding and contracting.\n* [AppBar], which is used by [SliverAppBar].\n* <https://material.google.com/patterns/scrolling-techniques.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "docs": "The primary contents of the flexible space bar when expanded.\n\nTypically a [Text] widget."
      },
      {
        "name": "background",
        "type": "Widget",
        "named": true,
        "docs": "Shown behind the [title] when expanded.\n\nTypically an [AssetImage] widget with [AssetImage.fit] set to [ImageFit.cover]."
      },
      {
        "name": "centerTitle",
        "type": "bool",
        "named": true,
        "docs": "Whether the title should be centered.\n\nDefaults to being adapted to the current [TargetPlatform]."
      }
    ]
  },
  "FloatingActionButton": {
    "name": "FloatingActionButton",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design floating action button.\n\nA floating action button is a circular icon button that hovers over content\nto promote a primary action in the application. Floating action buttons are\nmost commonly used in the [Scaffold.floatingActionButton] field.\n\nUse at most a single floating action button per screen. Floating action\nbuttons should be used for positive actions such as \"create\", \"share\", or\n\"navigate\".\n\nIf the [onPressed] callback is null, then the button will be disabled and\nwill not react to touch.\n\nSee also:\n\n* [Scaffold]\n* [RaisedButton]\n* [FlatButton]\n* <https://material.google.com/components/buttons-floating-action-button.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "tooltip",
        "type": "String",
        "named": true,
        "docs": "Text that describes the action that will occur when the button is pressed.\n\nThis text is displayed when the user long-presses on the button and is\nused for accessibility."
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use when filling the button.\n\nDefaults to the accent color of the current theme."
      },
      {
        "name": "heroTag",
        "type": "Object",
        "named": true,
        "docs": "The tag to apply to the button's [Hero] widget.\n\nDefaults to a tag that matches other floating action buttons."
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this button.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 6, the appropriate elevation for floating action buttons."
      },
      {
        "name": "highlightElevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this button when the user is touching the button.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 12, the appropriate elevation for floating action buttons\nwhile they are being touched."
      },
      {
        "name": "onPressed",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The callback that is called when the button is tapped or otherwise activated.\n\nIf this is set to null, the button will be disabled."
      },
      {
        "name": "mini",
        "type": "bool",
        "named": true,
        "docs": "Controls the size of this button.\n\nBy default, floating action buttons are non-mini and have a height and\nwidth of 56.0 logical pixels. Mini floating action buttons have a height\nand width of 40.0 logical pixels."
      }
    ]
  },
  "Flow": {
    "name": "Flow",
    "package": "widgets",
    "parent": "MultiChildRenderObjectWidget",
    "docs": "A widget that implements the flow layout algorithm.\n\nFlow layouts are optimized for repositioning children using transformation\nmatrices.\n\nThe flow container is sized independently from the children by the\n[FlowDelegate.getSize] function of the delegate. The children are then sized\nindependently given the constraints from the\n[FlowDelegate.getConstraintsForChild] function.\n\nRather than positioning the children during layout, the children are\npositioned using transformation matrices during the paint phase using the\nmatrices from the [FlowDelegate.paintChildren] function. The children can be\nrepositioned efficiently by simply repainting the flow.\n\nThe most efficient way to trigger a repaint of the flow is to supply a\nrepaint argument to the constructor of the [FlowDelegate]. The flow will\nlisten to this animation and repaint whenever the animation ticks, avoiding\nboth the build and layout phases of the pipeline.\n\nSee also:\n\n* [FlowDelegate], which controls the visual presentation of the children.\n* [Stack], which arranges children relative to the edges of the container.\n* [CustomSingleChildLayout], which uses a delegate to control the layout of\na single child.\n* [CustomMultiChildLayout], which uses a delegate to position multiple\nchildren.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "delegate",
        "type": "FlowDelegate",
        "named": true,
        "required": true,
        "docs": "The delegate that controls the transformation matrices of the children."
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "FlutterLogo": {
    "name": "FlutterLogo",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "The Flutter logo, in widget form. This widget respects the [IconTheme].\n\nSee also:\n\n* [IconTheme], which provides ambient configuration for icons.\n* [Icon], for showing icons the Material design icon library.\n* [ImageIcon], for showing icons from [AssetImage]s or other [ImageProvider]s.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "size",
        "type": "double",
        "named": true,
        "docs": "The size of the logo in logical pixels.\n\nThe logo will be fit into a square this size.\n\nDefaults to the current [IconTheme] size, if any. If there is no\n[IconTheme], or it does not specify an explicit size, then it defaults to\n24.0."
      },
      {
        "name": "swatch",
        "type": "Map",
        "named": true,
        "docs": "The colors to use to paint the logo. This map should contain at least two\nvalues, one for 400 and one for 900.\n\nIf possible, the default should be used. It corresponds to the\n[Colors.blue] swatch.\n\nIf for some reason that color scheme is impractical, the [Colors.amber],\n[Colors.red], or [Colors.indigo] swatches can be used. These are Flutter's\nsecondary colors.\n\nIn extreme cases where none of those four color schemes will work,\n[Colors.pink], [Colors.purple], or [Colors.cyan] swatches can be used.\nThese are Flutter's tertiary colors."
      },
      {
        "name": "textColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color used to paint the \"Flutter\" text on the logo, if [style] is\n[FlutterLogoStyle.horizontal] or [FlutterLogoStyle.stacked]. The\nappropriate color is `const Color(0xFF616161)` (a medium gray), against a\nwhite background."
      },
      {
        "name": "style",
        "type": "FlutterLogoStyle",
        "named": true,
        "docs": "Whether and where to draw the \"Flutter\" text. By default, only the logo\nitself is drawn."
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "docs": "The length of time for the animation if the [style], [swatch], or\n[textColor] properties are changed."
      },
      {
        "name": "curve",
        "type": "Curve",
        "named": true,
        "docs": "The curve for the logo animation if the [style], [swatch], or [textColor]\nchange."
      }
    ]
  },
  "Focus": {
    "name": "Focus",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A scope for managing the focus state of descendant widgets.\n\nThe focus represents where the user's attention is directed. If the use\ninteracts with the system in a way that isn't visually directed at a\nparticular widget (e.g., by typing on a keyboard), the interaction is\ndirected to the currently focused widget.\n\nThe focus system consists of a tree of Focus widgets, which is embedded in\nthe widget tree. Focus widgets themselves can be focused in their enclosing\nFocus widget, which means that their subtree is the one that has the current\nfocus. For example, a dialog creates a Focus widget to maintain focus\nwithin the dialog.  When the dialog closes, its Focus widget is removed from\nthe tree and focus is restored to whichever other part of the Focus tree\npreviously had focus.\n\nIn addition to tracking which enclosed Focus widget has focus, each Focus\nwidget also tracks a GlobalKey, which represents the currently focused\nwidget in this part of the focus tree. If this Focus widget is the currently\nfocused subtree of the focus system (i.e., the path from it to the root is\nfocused at each level and it hasn't focused any of its enclosed Focus\nwidgets), then the widget with this global key actually has the focus in the\nentire system.",
    "properties": [
      {
        "name": "key",
        "type": "GlobalKey",
        "named": true,
        "required": true
      },
      {
        "name": "initiallyFocusedScope",
        "type": "GlobalKey",
        "named": true,
        "docs": "The global key of the [Focus] widget below this widget in the tree that\nwill be focused initially.\n\nIf non-null, a [Focus] widget with this key must be added to the tree\nbefore the end of the current microtask in which the [Focus] widget was\ninitially constructed."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "Form": {
    "name": "Form",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "An optional container for grouping together multiple form field widgets\n(e.g. [Input] widgets).\n\nEach individual form field should be wrapped in a [FormField] widget, with\nthe [Form] widget as a common ancestor of all of those. Call methods on\n[FormState] to save, reset, or validate each [FormField] that is a\ndescendant of this [Form]. To obtain the [FormState], you may use [Form.of]\nwith a context whose ancestor is the [Form], or pass a [GlobalKey] to the\n[Form] constructor and call [GlobalKey.currentState].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "Root of the widget hierarchy that contains this form."
      },
      {
        "name": "autovalidate",
        "type": "bool",
        "named": true,
        "docs": "If true, form fields will validate and update their error text\nimmediately after every change. Otherwise, you must call\n[FormState.validate] to validate."
      },
      {
        "name": "onWillPop",
        "type": "WillPopCallback",
        "mutable": true,
        "named": true,
        "docs": "Enables the form to veto attempts by the user to dismiss the [ModalRoute]\nthat contains the form.\n\nIf the callback returns a Future that resolves to false, the form's route\nwill not be popped."
      }
    ]
  },
  "FormField": {
    "name": "FormField",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A single form field. This widget maintains the current state of the form\nfield, so that updates and validation errors are visually reflected in the\nUI.\n\nWhen used inside a [Form], you can use methods on [FormState] to query or\nmanipulate the form data as a whole. For example, calling [FormState.save]\nwill invoke each [FormField]'s [onSaved] callback in turn.\n\nUse a [GlobalKey] with [FormField] if you want to retrieve its current\nstate, for example if you want one form field to depend on another.\n\nA [Form] ancestor is not required. The [Form] simply makes it easier to\nsave, reset, or validate multiple fields at once. To use without a [Form],\npass a [GlobalKey] to the constructor and use [GlobalKey.currentState] to\nsave or reset the form field.\n\nSee also:\n\n* [Form], which is the widget that aggregates the form fields.\n* [TextField], which is a commonly used form field for entering text.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "builder",
        "type": "FormFieldBuilder",
        "named": true,
        "required": true,
        "docs": "Function that returns the widget representing this form field. It is\npassed the form field state as input, containing the current value and\nvalidation state of this field."
      },
      {
        "name": "onSaved",
        "type": "FormFieldSetter",
        "named": true,
        "docs": "An optional method to call with the final value when the form is saved via\nForm.save()."
      },
      {
        "name": "validator",
        "type": "FormFieldValidator",
        "named": true,
        "docs": "An optional method that validates an input. Returns an error string to\ndisplay if the input is invalid, or null otherwise."
      },
      {
        "name": "initialValue",
        "type": "T",
        "named": true,
        "docs": "An optional value to initialize the form field to, or null otherwise."
      },
      {
        "name": "autovalidate",
        "type": "bool",
        "named": true,
        "docs": "If true, this form fields will validate and update its error text\nimmediately after every change. Otherwise, you must call\n[FormFieldState.validate] to validate. If part of a [Form] that\nautovalidates, this value will be ignored."
      }
    ]
  },
  "FractionalTranslation": {
    "name": "FractionalTranslation",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that applies a translation expressed as a fraction of the box's\nsize before painting its child.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "translation",
        "type": "FractionalOffset",
        "named": true,
        "required": true,
        "docs": "The offset by which to translate the child, as a multiple of its size."
      },
      {
        "name": "transformHitTests",
        "type": "bool",
        "named": true,
        "docs": "Whether to apply the translation when performing hit tests."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "FractionallySizedBox": {
    "name": "FractionallySizedBox",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that sizes its child to a fraction of the total available space.\nFor more details about the layout algorithm, see [RenderFractionallySizedOverflowBox].\n\nSee also:\n\n* [Align] (which sizes itself based on its child's size and positions\nthe child according to a [FractionalOffset] value)\n* [OverflowBox]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "How to align the child.\n\nThe x and y values of the alignment control the horizontal and vertical\nalignment, respectively.  An x value of 0.0 means that the left edge of\nthe child is aligned with the left edge of the parent whereas an x value\nof 1.0 means that the right edge of the child is aligned with the right\nedge of the parent. Other values interpolate (and extrapolate) linearly.\nFor example, a value of 0.5 means that the center of the child is aligned\nwith the center of the parent."
      },
      {
        "name": "widthFactor",
        "type": "double",
        "named": true,
        "docs": "If non-null, the fraction of the incoming width given to the child.\n\nIf non-null, the child is given a tight width constraint that is the max\nincoming width constraint multipled by this factor.\n\nIf null, the incoming width constraints are passed to the child\nunmodified."
      },
      {
        "name": "heightFactor",
        "type": "double",
        "named": true,
        "docs": "If non-null, the fraction of the incoming height given to the child.\n\nIf non-null, the child is given a tight height constraint that is the max\nincoming height constraint multipled by this factor.\n\nIf null, the incoming height constraints are passed to the child\nunmodified."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "FutureBuilder": {
    "name": "FutureBuilder",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "Widget that builds itself based on the latest snapshot of interaction with\na [Future].\n\nWidget rebuilding is scheduled by the completion of the future, using\n[State.setState], but is otherwise decoupled from the timing of the future.\nThe [build] method is called at the discretion of the Flutter pipeline, and\nwill thus receive a timing-dependent sub-sequence of the snapshots that\nrepresent the interaction with the future.\n\nFor a future that completes successfully with data, the [build] method may\nbe called with either both or only the latter of the following snapshots:\n\n* `new AsyncSnapshot<String>(ConnectionState.waiting, null, null)`\n* `new AsyncSnapshot<String>(ConnectionState.done, 'some data', null)`\n\nFor a future completing with an error, the [build] method may be called with\neither both or only the latter of:\n\n* `new AsyncSnapshot<String>(ConnectionState.waiting, null, null)`\n* `new AsyncSnapshot<String>(ConnectionState.done, null, 'some error')`\n\nThe data and error fields of the snapshot change only as the connection\nstate field transitions from `waiting` to `done`, and they will be retained\nwhen changing the [FutureBuilder] configuration to another future. If the\nold future has already completed successfully with data as above, changing\nconfiguration to a new future results in snapshot pairs of the form:\n\n* `new AsyncSnapshot<String>(ConnectionState.none, 'some data', null)`\n* `new AsyncSnapshot<String>(ConnectionState.waiting, 'some data', null)`\n\nIn general, the latter will be produced only when the new future is\nnon-`null`. The former only when the old future is non-`null`.\n\nA [FutureBuilder] behaves identically to a [StreamBuilder] configured with\n`future?.asStream()`, except that snapshots with `ConnectionState.active`\nmay appear for the latter, depending on how the stream is implemented.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "future",
        "type": "Future",
        "named": true,
        "docs": "The asynchronous computation to which this builder is currently connected,\npossibly `null`."
      },
      {
        "name": "builder",
        "type": "AsyncWidgetBuilder",
        "named": true,
        "required": true,
        "docs": "The build strategy currently used by this builder. Cannot be `null`."
      }
    ]
  },
  "GestureDetector": {
    "name": "GestureDetector",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A widget that detects gestures.\n\nAttempts to recognize gestures that correspond to its non-null callbacks.\n\nIf this widget has a child, it defers to that child for its sizing behavior.\nIf it does not have a child, it grows to fit the parent instead.\n\nGestureDetector also listens for accessibility events and maps\nthem to the callbacks. To ignore accessibility events, set\n[excludeFromSemantics] to true.\n\nSee http://flutter.io/gestures/ for additional information.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "onTapDown",
        "type": "GestureTapDownCallback",
        "named": true,
        "docs": "A pointer that might cause a tap has contacted the screen at a particular\nlocation."
      },
      {
        "name": "onTapUp",
        "type": "GestureTapUpCallback",
        "named": true,
        "docs": "A pointer that will trigger a tap has stopped contacting the screen at a\nparticular location."
      },
      {
        "name": "onTap",
        "type": "GestureTapCallback",
        "named": true,
        "docs": "A tap has occurred."
      },
      {
        "name": "onTapCancel",
        "type": "GestureTapCancelCallback",
        "named": true,
        "docs": "The pointer that previously triggered [onTapDown] will not end up causing\na tap."
      },
      {
        "name": "onDoubleTap",
        "type": "GestureTapCallback",
        "named": true,
        "docs": "The user has tapped the screen at the same location twice in quick\nsuccession."
      },
      {
        "name": "onLongPress",
        "type": "GestureLongPressCallback",
        "named": true,
        "docs": "A pointer has remained in contact with the screen at the same location for\na long period of time."
      },
      {
        "name": "onVerticalDragDown",
        "type": "GestureDragDownCallback",
        "named": true,
        "docs": "A pointer has contacted the screen and might begin to move vertically."
      },
      {
        "name": "onVerticalDragStart",
        "type": "GestureDragStartCallback",
        "named": true,
        "docs": "A pointer has contacted the screen and has begun to move vertically."
      },
      {
        "name": "onVerticalDragUpdate",
        "type": "GestureDragUpdateCallback",
        "named": true,
        "docs": "A pointer that is in contact with the screen and moving vertically has\nmoved in the vertical direction."
      },
      {
        "name": "onVerticalDragEnd",
        "type": "GestureDragEndCallback",
        "named": true,
        "docs": "A pointer that was previously in contact with the screen and moving\nvertically is no longer in contact with the screen and was moving at a\nspecific velocity when it stopped contacting the screen."
      },
      {
        "name": "onVerticalDragCancel",
        "type": "GestureDragCancelCallback",
        "named": true,
        "docs": "The pointer that previously triggered [onVerticalDragDown] did not\ncomplete."
      },
      {
        "name": "onHorizontalDragDown",
        "type": "GestureDragDownCallback",
        "named": true,
        "docs": "A pointer has contacted the screen and might begin to move horizontally."
      },
      {
        "name": "onHorizontalDragStart",
        "type": "GestureDragStartCallback",
        "named": true,
        "docs": "A pointer has contacted the screen and has begun to move horizontally."
      },
      {
        "name": "onHorizontalDragUpdate",
        "type": "GestureDragUpdateCallback",
        "named": true,
        "docs": "A pointer that is in contact with the screen and moving horizontally has\nmoved in the horizontal direction."
      },
      {
        "name": "onHorizontalDragEnd",
        "type": "GestureDragEndCallback",
        "named": true,
        "docs": "A pointer that was previously in contact with the screen and moving\nhorizontally is no longer in contact with the screen and was moving at a\nspecific velocity when it stopped contacting the screen."
      },
      {
        "name": "onHorizontalDragCancel",
        "type": "GestureDragCancelCallback",
        "named": true,
        "docs": "The pointer that previously triggered [onHorizontalDragDown] did not\ncomplete."
      },
      {
        "name": "onPanDown",
        "type": "GestureDragDownCallback",
        "named": true,
        "docs": "A pointer has contacted the screen and might begin to move."
      },
      {
        "name": "onPanStart",
        "type": "GestureDragStartCallback",
        "named": true,
        "docs": "A pointer has contacted the screen and has begun to move."
      },
      {
        "name": "onPanUpdate",
        "type": "GestureDragUpdateCallback",
        "named": true,
        "docs": "A pointer that is in contact with the screen and moving has moved again."
      },
      {
        "name": "onPanEnd",
        "type": "GestureDragEndCallback",
        "named": true,
        "docs": "A pointer that was previously in contact with the screen and moving\nis no longer in contact with the screen and was moving at a specific\nvelocity when it stopped contacting the screen."
      },
      {
        "name": "onPanCancel",
        "type": "GestureDragCancelCallback",
        "named": true,
        "docs": "The pointer that previously triggered [onPanDown] did not complete."
      },
      {
        "name": "onScaleStart",
        "type": "GestureScaleStartCallback",
        "named": true,
        "docs": "The pointers in contact with the screen have established a focal point and\ninitial scale of 1.0."
      },
      {
        "name": "onScaleUpdate",
        "type": "GestureScaleUpdateCallback",
        "named": true,
        "docs": "The pointers in contact with the screen have indicated a new focal point\nand/or scale."
      },
      {
        "name": "onScaleEnd",
        "type": "GestureScaleEndCallback",
        "named": true,
        "docs": "The pointers are no longer in contact with the screen."
      },
      {
        "name": "behavior",
        "type": "HitTestBehavior",
        "named": true,
        "docs": "How this gesture detector should behave during hit testing."
      },
      {
        "name": "excludeFromSemantics",
        "type": "bool",
        "named": true,
        "docs": "Whether to exclude these gestures from the semantics tree. For\nexample, the long-press gesture for showing a tooltip is\nexcluded because the tooltip itself is included in the semantics\ntree directly and so having a gesture to show it would result in\nduplication of information."
      }
    ]
  },
  "GlowingOverscrollIndicator": {
    "name": "GlowingOverscrollIndicator",
    "package": "widgets",
    "parent": "StatefulWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "showLeading",
        "type": "bool",
        "named": true,
        "docs": "Whether to show the overscroll glow on the side with negative scroll\noffsets.\n\nFor a vertical downwards viewport, this is the top side.\n\nDefaults to true.\n\nSee [showTrailing] for the corresponding control on the other side of the\nviewport."
      },
      {
        "name": "showTrailing",
        "type": "bool",
        "named": true,
        "docs": "Whether to show the overscroll glow on the side with positive scroll\noffsets.\n\nFor a vertical downwards viewport, this is the bottom side.\n\nDefaults to true.\n\nSee [showLeading] for the corresponding control on the other side of the\nviewport."
      },
      {
        "name": "axisDirection",
        "type": "AxisDirection",
        "named": true,
        "required": true,
        "docs": "The direction of positive scroll offsets in the viewport of the\n[Scrollable] whose overscrolls are to be visualized."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The color of the glow. The alpha channel is ignored."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The subtree to place inside the overscroll indicator. This should include\na source of [ScrollNotification] notifications, typically a [Scrollable]\nwidget.\n\nTypically a [GlowingOverscrollIndicator] is created by a\n[ScrollBehavior.buildViewportChrome] method, in which case\nthe child is usually the one provided as an argument to that method."
      }
    ]
  },
  "GridPaper": {
    "name": "GridPaper",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A widget that draws a rectilinear grid of 1px wide lines.\n\nUseful with a [Stack] for visualizing your layout along a grid.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color to draw the lines in the grid."
      },
      {
        "name": "interval",
        "type": "double",
        "named": true,
        "docs": "The distance between the primary lines in the grid, in logical pixels."
      },
      {
        "name": "divisions",
        "type": "int",
        "named": true,
        "docs": "The number of major divisions within each primary grid cell."
      },
      {
        "name": "subDivisions",
        "type": "int",
        "named": true,
        "docs": "The number of minor divisions within each major division."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "GridTile": {
    "name": "GridTile",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A tile in a material design grid list.\n\nA grid list is a [GridView] of tiles in a vertical and horizontal\narray. Each tile typically contains some visually rich content (e.g., an\nimage) together with a [GridTileBar] in either a [header] or a [footer].\n\nSee also:\n\n* [GridView], which is a scrollable grid of tiles.\n* [GridTileBar], which is typically used in either the [header] or\n[footer].\n* <https://material.google.com/components/grid-lists.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "header",
        "type": "Widget",
        "named": true,
        "docs": "The widget to show over the top of this grid tile.\n\nTypically a [GridTileBar]."
      },
      {
        "name": "footer",
        "type": "Widget",
        "named": true,
        "docs": "The widget to show over the bottom of this grid tile.\n\nTypically a [GridTileBar]."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget that fills the tile."
      }
    ]
  },
  "GridTileBar": {
    "name": "GridTileBar",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A header used in a material design [GridTile].\n\nTypically used to add a one or two line header or footer on a [GridTile].\n\nFor a one-line header, include a [title] widget. To add a second line, also\ninclude a [subtitle] wiget. Use [leading] or [trailing] to add an icon.\n\nSee also:\n\n* [GridTile]\n* <https://material.google.com/components/grid-lists.html#grid-lists-specs>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to paint behind the child widgets.\n\nDefaults to transparent."
      },
      {
        "name": "leading",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display before the title.\n\nTypically an [Icon] or an [IconButton] widget."
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "docs": "The primary content of the list item.\n\nTypically a [Text] widget."
      },
      {
        "name": "subtitle",
        "type": "Widget",
        "named": true,
        "docs": "Additional content displayed below the title.\n\nTypically a [Text] widget."
      },
      {
        "name": "trailing",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display after the title.\n\nTypically an [Icon] or an [IconButton] widget."
      }
    ]
  },
  "GridView": {
    "name": "GridView",
    "package": "widgets",
    "parent": "BoxScrollView",
    "docs": "A scrollable grid of boxes.\n\nSee also:\n\n* [SingleChildScrollView], when you need to make a single child scrollable.\n* [ListView], for a scrollable list of boxes.\n* [PageView], for a scrollable that works page by page.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "scrollDirection",
        "type": "Axis",
        "named": true
      },
      {
        "name": "reverse",
        "type": "bool",
        "named": true
      },
      {
        "name": "controller",
        "type": "ScrollController",
        "named": true
      },
      {
        "name": "primary",
        "type": "bool",
        "named": true
      },
      {
        "name": "physics",
        "type": "ScrollPhysics",
        "named": true
      },
      {
        "name": "shrinkWrap",
        "type": "bool",
        "named": true
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true
      },
      {
        "name": "gridDelegate",
        "type": "SliverGridDelegate",
        "named": true,
        "required": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "Hero": {
    "name": "Hero",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that marks its child as being a candidate for hero animations.\n\nWhen a [PageRoute] is pushed or popped with the [Navigator], the entire\nscreen's content is replaced. An old route disappears and a new route\nappears. If there's a common visual feature on both routes then it can\nbe helpful for orienting the user for the feature to physically move from\none page to the other during the routes' transition. Such an animation\nis called a *hero animation*. The hero widgets \"fly\" in the Navigator's\noverlay during the transition and while they're in-flight they're\nnot shown in their original locations in the old and new routes.\n\nTo label a widget as such a feature, wrap it in a [Hero] widget. When\nnavigation happens, the [Hero] widgets on each route are identified\nby the [HeroController]. For each pair of [Hero] widgets that have the\nsame tag, a hero animation is triggered.\n\nIf a [Hero] is already in flight when navigation occurs, its\nflight animation will be redirected to its new destination.\n\nRoutes must not contain more than one [Hero] for each [tag].\n\n## Discussion\n\nHeroes and the [Navigator]'s [Overlay] [Stack] must be axis-aligned for\nall this to work. The top left and bottom right coordinates of each animated\nHero will be converted to global coordinates and then from there converted\nto that [Stack]'s coordinate space, and the entire Hero subtree will, for\nthe duration of the animation, be lifted out of its original place, and\npositioned on that stack. If the [Hero] isn't axis aligned, this is going to\nfail in a rather ugly fashion. Don't rotate your heroes!\n\nTo make the animations look good, it's critical that the widget tree for the\nhero in both locations be essentially identical. The widget of the *target*\nis used to do the transition: when going from route A to route B, route B's\nhero's widget is placed over route A's hero's widget, and route A's hero is\nhidden. Then the widget is animated to route B's hero's position, and then\nthe widget is inserted into route B. When going back from B to A, route A's\nhero's widget is placed over where route B's hero's widget was, and then the\nanimation goes the other way.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "tag",
        "type": "Object",
        "named": true,
        "required": true,
        "docs": "The identifier for this particular hero. If the tag of this hero matches\nthe tag of a hero on a [PageRoute] that we're navigating to or from, then\na hero animation will be triggered."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget subtree that will \"fly\" from one route to another during a\n[Naviator] push or pop transition.\n\nThe appearance of this subtree should be similar to the appearance of\nthe subtrees of any other heroes in the application with the same [tag].\nChanges in scale and aspect ratio work well in hero animations, changes\nin layout or composition do not."
      }
    ]
  },
  "Icon": {
    "name": "Icon",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design icon.\n\nIcons are not interactive. For an interactive icon, consider [IconButton].\n\nIcons are identified by their name (as given on that page), with spaces\nconverted to underscores, from the [Icons] class. For example, the \"alarm\nadd\" icon is [Icons.alarm_add].\n\nAvailable icons are shown on this page: <https://design.google.com/icons/>\n\nTo use this class, make sure you set `uses-material-design: true` in your\nproject's `pubspec.yaml` file in the `flutter` section. This ensures that\nthe MaterialIcons font is included in your application. This font is used to\ndisplay the icons. For example:\n\n```yaml\nname: my_awesome_application\nflutter:\nuses-material-design: true\n```\n\nSee also:\n\n* [IconButton], for interactive icons.\n* [Icons], for the list of available icons for use with this class.\n* [IconTheme], which provides ambient configuration for icons.\n* [ImageIcon], for showing icons from [AssetImage]s or other [ImageProvider]s.",
    "properties": [
      {
        "name": "icon",
        "type": "IconData",
        "required": true,
        "docs": "The icon to display. The available icons are described in [Icons].\n\nThe icon can be null, in which case the widget will render as an empty\nspace of the specified [size]."
      },
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "size",
        "type": "double",
        "named": true,
        "docs": "The size of the icon in logical pixels.\n\nIcons occupy a square with width and height equal to size.\n\nDefaults to the current [IconTheme] size, if any. If there is no\n[IconTheme], or it does not specify an explicit size, then it defaults to\n24.0.\n\nIf this [Icon] is being placed inside an [IconButton], then use\n[IconButton.size] instead, so that the [IconButton] can make the splash\narea the appropriate size as well. The [IconButton] uses an [IconTheme] to\npass down the size to the [Icon]."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use when drawing the icon.\n\nDefaults to the current [IconTheme] color, if any. If there is\nno [IconTheme], then it defaults to white if the theme is dark\nand black if the theme is light. See [Theme] to set the current\ntheme and [ThemeData.brightness] for setting the current theme's\nbrightness.\n\nThe given color will be adjusted by the opacity of the current\n[IconTheme], if any.\n\nTypically, a material design color will be used, as follows:\n\n```dart\nnew Icon(\nicon: Icons.widgets,\ncolor: Colors.blue[400],\n),\n```"
      }
    ]
  },
  "IconButton": {
    "name": "IconButton",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design icon button.\n\nAn icon button is a picture printed on a [Material] widget that reacts to\ntouches by filling with color.\n\nIcon buttons are commonly used in the [AppBar.actions] field, but they can\nbe used in many other places as well.\n\nIf the [onPressed] callback is null, then the button will be disabled and\nwill not react to touch.\n\nRequires one of its ancestors to be a [Material] widget.\n\nWill be automatically sized up to the recommended 48 logical pixels if smaller.\n\nSee also:\n\n* [Icons]\n* [AppBar]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "iconSize",
        "type": "double",
        "named": true,
        "docs": "The size of the icon inside the button.\n\nThis property must not be null. It defaults to 24.0.\n\nThe size given here is passed down to the widget in the [icon] property\nvia an [IconTheme]. Setting the size here instead of in, for example, the\n[Icon.size] property allows the [IconButton] to size the splash area to\nfit the [Icon]. If you were to set the size of the [Icon] using\n[Icon.size] instead, then the [IconButton] would default to 24.0 and then\nthe [Icon] itself would likely get clipped."
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "The padding around the button's icon. The entire padded icon will react\nto input gestures.\n\nThis property must not be null. It defaults to 8.0 padding on all sides."
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "Defines how the icon is positioned within the IconButton.\n\nThis property must not be null. It defaults to [FractionalOffset.center]."
      },
      {
        "name": "icon",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The icon to display inside the button.\n\nThe [size] and [color] of the icon is configured automatically based on\nthe properties of _this_ widget using an [IconTheme] and therefore should\nnot be explicitly given in the icon widget.\n\nThis property must not be null.\n\nSee [Icon], [ImageIcon]."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use for the icon inside the button, if the icon is enabled.\nDefaults to leaving this up to the [icon] widget.\n\nThe icon is enabled if [onPressed] is not null.\n\nSee also [disabledColor].\n\n```dart\nnew IconButton(\ncolor: Colors.blue[500],\nonPressed: _handleTap,\nicon: Icons.widgets,\n),\n```"
      },
      {
        "name": "disabledColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use for the icon inside the button, if the icon is disabled.\nDefaults to the [ThemeData.disabledColor] of the current [Theme].\n\nThe icon is disabled if [onPressed] is null.\n\nSee also [color]."
      },
      {
        "name": "onPressed",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The callback that is called when the button is tapped or otherwise activated.\n\nIf this is set to null, the button will be disabled."
      },
      {
        "name": "tooltip",
        "type": "String",
        "named": true,
        "docs": "Text that describes the action that will occur when the button is pressed.\n\nThis text is displayed when the user long-presses on the button and is\nused for accessibility."
      }
    ]
  },
  "IconTheme": {
    "name": "IconTheme",
    "package": "material",
    "parent": "InheritedWidget",
    "docs": "Controls the default color, opacity, and size of icons in a widget subtree.\n\nThe icon theme is honored by [Icon] and [ImageIcon] widgets.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "data",
        "type": "IconThemeData",
        "named": true,
        "required": true,
        "docs": "The color, opacity, and size to use for icons in this subtree."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "IgnorePointer": {
    "name": "IgnorePointer",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that is invisible during hit testing.\n\nWhen [ignoring] is true, this widget (and its subtree) is invisible\nto hit testing. It still consumes space during layout and paints its child\nas usual. It just cannot be the target of located events, because it returns\nfalse from [hitTest].\n\nWhen [ignoringSemantics] is true, the subtree will be invisible to\nthe semantics layer (and thus e.g. accessibility tools). If\n[ignoringSemantics] is null, it uses the value of [ignoring].\n\nSee also:\n\n* [AbsorbPointer], which also prevents its children from receiving pointer\nevents but is itself visible to hit testing.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "ignoring",
        "type": "bool",
        "named": true,
        "docs": "Whether this widget is ignored during hit testing.\n\nRegardless of whether this widget is ignored during hit testing, it will\nstill consume space during layout and be visible during painting."
      },
      {
        "name": "ignoringSemantics",
        "type": "bool",
        "named": true,
        "docs": "Whether the semantics of this widget is ignored when compiling the semantics tree.\n\nIf null, defaults to value of [ignoring].\n\nSee [SemanticsNode] for additional information about the semantics tree."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Image": {
    "name": "Image",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that displays an image.\n\nSeveral constructors are provided for the various ways that an image can be\nspecified:\n\n* [new Image], for obtaining an image from an [ImageProvider].\n* [new Image.asset], for obtaining an image from an [AssetBundle]\nusing a key.\n* [new Image.network], for obtaining an image from a URL.\n* [new Image.file], for obtaining an image from a [File].\n\nTo automatically perform pixel-density-aware asset resolution, specify the\nimage using an [AssetImage] and make sure that a [MaterialApp], [WidgetsApp],\nor [MediaQuery] widget exists above the [Image] widget in the widget tree.\n\nThe image is painted using [paintImage], which describes the meanings of the\nvarious fields on this class in more detail.\n\nSee also:\n\n* [Icon]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "image",
        "type": "ImageProvider",
        "named": true,
        "required": true,
        "docs": "The image to display."
      },
      {
        "name": "width",
        "type": "double",
        "named": true,
        "docs": "If non-null, require the image to have this width.\n\nIf null, the image will pick a size that best preserves its intrinsic\naspect ratio."
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "If non-null, require the image to have this height.\n\nIf null, the image will pick a size that best preserves its intrinsic\naspect ratio."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "If non-null, apply this color filter to the image before painting."
      },
      {
        "name": "fit",
        "type": "ImageFit",
        "named": true,
        "docs": "How to inscribe the image into the space allocated during layout.\n\nThe default varies based on the other fields. See the discussion at\n[paintImage]."
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "How to align the image within its bounds.\n\nAn alignment of (0.0, 0.0) aligns the image to the top-left corner of its\nlayout bounds.  An alignment of (1.0, 0.5) aligns the image to the middle\nof the right edge of its layout bounds."
      },
      {
        "name": "repeat",
        "type": "ImageRepeat",
        "named": true,
        "docs": "How to paint any portions of the layout bounds not covered by the image."
      },
      {
        "name": "centerSlice",
        "type": "dynamic",
        "named": true,
        "docs": "The center slice for a nine-patch image.\n\nThe region of the image inside the center slice will be stretched both\nhorizontally and vertically to fit the image into its destination. The\nregion of the image above and below the center slice will be stretched\nonly horizontally and the region of the image to the left and right of\nthe center slice will be stretched only vertically."
      },
      {
        "name": "gaplessPlayback",
        "type": "bool",
        "named": true,
        "docs": "Whether to continue showing the old image (true), or briefly show nothing\n(false), when the image provider changes."
      }
    ]
  },
  "ImageIcon": {
    "name": "ImageIcon",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "An icon that comes from an [ImageProvider], e.g. an [AssetImage].\n\nSee also:\n\n* [IconButton], for interactive icons.\n* [IconTheme], which provides ambient configuration for icons.\n* [Icon] and [Icons], for icons from the material design library.",
    "properties": [
      {
        "name": "image",
        "type": "ImageProvider",
        "required": true,
        "docs": "The image to display as the icon.\n\nThe icon can be null, in which case the widget will render as an empty\nspace of the specified [size]."
      },
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "size",
        "type": "double",
        "named": true,
        "docs": "The size of the icon in logical pixels.\n\nIcons occupy a square with width and height equal to size.\n\nDefaults to the current [IconTheme] size, if any. If there is no\n[IconTheme], or it does not specify an explicit size, then it defaults to\n24.0."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use when drawing the icon.\n\nDefaults to the current [IconTheme] color, if any. If there is\nno [IconTheme], then it defaults to not recolorizing the image.\n\nThe image will additionally be adjusted by the opacity of the current\n[IconTheme], if any."
      }
    ]
  },
  "ImplicitlyAnimatedWidget": {
    "name": "ImplicitlyAnimatedWidget",
    "package": "widgets",
    "parent": "StatefulWidget",
    "abstract": true,
    "docs": "An abstract widget for building widgets that gradually change their\nvalues over a period of time.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "curve",
        "type": "Curve",
        "named": true,
        "docs": "The curve to apply when animating the parameters of this container."
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "required": true,
        "docs": "The duration over which to animate the parameters of this container."
      }
    ]
  },
  "IndexedStack": {
    "name": "IndexedStack",
    "package": "widgets",
    "parent": "Stack",
    "docs": "A [Stack] that shows a single child from a list of children.\n\nThe displayed child is the one with the given [index]. The stack is\nalways as big as the largest child.\n\nIf value is null, then nothing is displayed.\n\nFor more details, see [Stack].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true
      },
      {
        "name": "index",
        "type": "int",
        "named": true,
        "docs": "The index of the child to show."
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "InheritedWidget": {
    "name": "InheritedWidget",
    "package": "widgets",
    "parent": "ProxyWidget",
    "abstract": true,
    "docs": "Base class for widgets that efficiently propagate information down the tree.\n\nTo obtain the nearest instance of a particular type of inherited widget from\na build context, use [BuildContext.inheritFromWidgetOfExactType].\n\nInherited widgets, when referenced in this way, will cause the consumer to\nrebuild when the inherited widget itself changes state.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "InkResponse": {
    "name": "InkResponse",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "An area of a [Material] that responds to touch. Has a configurable shape and\ncan be configured to clip splashes that extend outside its bounds or not.\n\nFor a variant of this widget that is specialized for rectangular areas that\nalways clip splashes, see [InkWell].\n\nMust have an ancestor [Material] widget in which to cause ink reactions.\n\nIf a Widget uses this class directly, it should include the following line\nat the top of its [build] function to call [debugCheckHasMaterial]:\n\nassert(debugCheckHasMaterial(context));",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "onTap",
        "type": "GestureTapCallback",
        "named": true,
        "docs": "Called when the user taps this part of the material"
      },
      {
        "name": "onDoubleTap",
        "type": "GestureTapCallback",
        "named": true,
        "docs": "Called when the user double taps this part of the material."
      },
      {
        "name": "onLongPress",
        "type": "GestureLongPressCallback",
        "named": true,
        "docs": "Called when the user long-presses on this part of the material."
      },
      {
        "name": "onHighlightChanged",
        "type": "ValueChanged",
        "named": true,
        "docs": "Called when this part of the material either becomes highlighted or stops behing highlighted.\n\nThe value passed to the callback is true if this part of the material has\nbecome highlighted and false if this part of the material has stopped\nbeing highlighted."
      },
      {
        "name": "containedInkWell",
        "type": "bool",
        "named": true,
        "docs": "Whether this ink response should be clipped its bounds."
      },
      {
        "name": "highlightShape",
        "type": "BoxShape",
        "named": true,
        "docs": "The shape (e.g., circle, rectangle) to use for the highlight drawn around this part of the material."
      },
      {
        "name": "radius",
        "type": "double",
        "named": true,
        "docs": "The radius of the ink splash."
      }
    ]
  },
  "InkWell": {
    "name": "InkWell",
    "package": "material",
    "parent": "InkResponse",
    "docs": "A rectangular area of a [Material] that responds to touch.\n\nMust have an ancestor [Material] widget in which to cause ink reactions.\n\nIf a Widget uses this class directly, it should include the following line\nat the top of its [build] function to call [debugCheckHasMaterial]:\n\nassert(debugCheckHasMaterial(context));",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      },
      {
        "name": "onTap",
        "type": "GestureTapCallback",
        "named": true
      },
      {
        "name": "onDoubleTap",
        "type": "GestureTapCallback",
        "named": true
      },
      {
        "name": "onLongPress",
        "type": "GestureLongPressCallback",
        "named": true
      },
      {
        "name": "onHighlightChanged",
        "type": "ValueChanged",
        "named": true
      }
    ]
  },
  "Input": {
    "name": "Input",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design text input field.\n\nThe [value] field must be updated each time the [onChanged] callback is\ninvoked. Be sure to include the full [value] provided by the [onChanged]\ncallback, or information like the current selection will be lost.\n\nRequires one of its ancestors to be a [Material] widget.\n\nWhen using inside a [Form], consider using [TextField] instead.\n\nAssuming that the input is already focused, the basic data flow for\nretrieving user input is:\n1. User taps a character on the keyboard.\n2. The [onChanged] callback is called with the current [InputValue].\n3. Perform any necessary logic/validation on the current input value.\n4. Update the state of the [Input] widget accordingly through [State.setState].\n\nFor most cases, we recommend that you use the [Input] class within a\n[StatefulWidget] so you can save and operate on the current value of the\ninput.\n\nSee also:\n\n* <https://material.google.com/components/text-fields.html>\n* [TextField], which simplifies steps 2-4 above.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "InputValue",
        "named": true,
        "docs": "The current state of text of the input field. This includes the selected\ntext, if any, among other things."
      },
      {
        "name": "keyboardType",
        "type": "TextInputType",
        "named": true,
        "docs": "The type of keyboard to use for editing the text."
      },
      {
        "name": "icon",
        "type": "Widget",
        "named": true,
        "docs": "An icon to show adjacent to the input field.\n\nThe size and color of the icon is configured automatically using an\n[IconTheme] and therefore does not need to be explicitly given in the\nicon widget.\n\nSee [Icon], [ImageIcon]."
      },
      {
        "name": "labelText",
        "type": "String",
        "named": true,
        "docs": "Text to show above the input field."
      },
      {
        "name": "hintText",
        "type": "String",
        "named": true,
        "docs": "Text to show inline in the input field when it would otherwise be empty."
      },
      {
        "name": "errorText",
        "type": "String",
        "named": true,
        "docs": "Text to show when the input text is invalid."
      },
      {
        "name": "style",
        "type": "TextStyle",
        "named": true,
        "docs": "The style to use for the text being edited."
      },
      {
        "name": "obscureText",
        "type": "bool",
        "named": true,
        "docs": "Whether to hide the text being edited (e.g., for passwords).\n\nWhen this is set to true, all the characters in the input are replaced by\nU+2022 BULLET characters (•).\n\nDefaults to false."
      },
      {
        "name": "showDivider",
        "type": "bool",
        "named": true,
        "docs": "Whether to show a divider below the child and above the error text.\n\nDefaults to true."
      },
      {
        "name": "isDense",
        "type": "bool",
        "named": true,
        "docs": "Whether the input field is part of a dense form (i.e., uses less vertical space).\nIf true, [errorText] is not shown.\n\nDefaults to false."
      },
      {
        "name": "autofocus",
        "type": "bool",
        "named": true,
        "docs": "Whether this input field should focus itself if nothing else is already focused.\nIf true, the keyboard will open as soon as this input obtains focus. Otherwise,\nthe keyboard is only shown after the user taps the text field.\n\nDefaults to false."
      },
      {
        "name": "maxLines",
        "type": "int",
        "named": true,
        "docs": "The maximum number of lines for the text to span, wrapping if necessary.\nIf this is 1 (the default), the text will not wrap, but will scroll\nhorizontally instead."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "docs": "Called when the text being edited changes.\n\nThe [value] must be updated each time [onChanged] is invoked."
      },
      {
        "name": "onSubmitted",
        "type": "ValueChanged",
        "named": true,
        "docs": "Called when the user indicates that they are done editing the text in the field."
      }
    ]
  },
  "InputContainer": {
    "name": "InputContainer",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "Displays the visual elements of a material design text field around an\narbitrary child widget.\n\nUse InputContainer to create widgets that look and behave like the [Input]\nwidget.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [Input], which combines an [InputContainer] with an [InputField].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "focused",
        "type": "bool",
        "named": true,
        "docs": "True if the hint and label should be displayed as if the child had the focus.\n\nDefaults to false."
      },
      {
        "name": "isEmpty",
        "type": "bool",
        "named": true,
        "docs": "Should the hint and label be displayed as if no value had been input\nto the child.\n\nDefaults to false."
      },
      {
        "name": "icon",
        "type": "Widget",
        "named": true,
        "docs": "An icon to show adjacent to the input field.\n\nThe size and color of the icon is configured automatically using an\n[IconTheme] and therefore does not need to be explicitly given in the\nicon widget.\n\nSee [Icon], [ImageIcon]."
      },
      {
        "name": "labelText",
        "type": "String",
        "named": true,
        "docs": "Text that appears above the child or over it, if isEmpty is true."
      },
      {
        "name": "hintText",
        "type": "String",
        "named": true,
        "docs": "Text that appears over the child if isEmpty is true and labelText is null."
      },
      {
        "name": "errorText",
        "type": "String",
        "named": true,
        "docs": "Text that appears below the child. If errorText is non-null the divider\nthat appears below the child is red."
      },
      {
        "name": "style",
        "type": "TextStyle",
        "named": true,
        "docs": "The style to use for the hint. It's also used for the label when the label\nappears over the child."
      },
      {
        "name": "isDense",
        "type": "bool",
        "named": true,
        "docs": "Whether the input container is part of a dense form (i.e., uses less vertical space).\n\nDefaults to false."
      },
      {
        "name": "showDivider",
        "type": "bool",
        "named": true,
        "docs": "Whether to show a divider below the child and above the error text.\n\nDefaults to true."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "InputField": {
    "name": "InputField",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A simple undecorated text input field.\n\nIf you want decorations as specified in the Material spec (most likely),\nuse [Input] instead.\n\nThis widget is comparable to [Text] in that it does not include a margin\nor any decoration outside the text itself. It is useful for applications,\nlike a search box, that don't need any additional decoration. It should\nalso be useful in custom widgets that support text input.\n\nThe [value] field must be updated each time the [onChanged] callback is\ninvoked. Be sure to include the full [value] provided by the [onChanged]\ncallback, or information like the current selection will be lost.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [Input], which adds a label, a divider below the text field, and support for\nan error message.\n* [EditableText], a text field that does not require [Material] design.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "focusKey",
        "type": "GlobalKey",
        "named": true
      },
      {
        "name": "value",
        "type": "InputValue",
        "named": true,
        "docs": "The current state of text of the input field. This includes the selected\ntext, if any, among other things."
      },
      {
        "name": "keyboardType",
        "type": "TextInputType",
        "named": true,
        "docs": "The type of keyboard to use for editing the text."
      },
      {
        "name": "hintText",
        "type": "String",
        "named": true,
        "docs": "Text to show inline in the input field when it would otherwise be empty."
      },
      {
        "name": "style",
        "type": "TextStyle",
        "named": true,
        "docs": "The style to use for the text being edited."
      },
      {
        "name": "hintStyle",
        "type": "TextStyle",
        "named": true,
        "docs": "The style to use for the hint text.\n\nDefaults to the specified TextStyle in style with the hintColor from\nthe ThemeData"
      },
      {
        "name": "obscureText",
        "type": "bool",
        "named": true,
        "docs": "Whether to hide the text being edited (e.g., for passwords).\n\nWhen this is set to true, all the characters in the input are replaced by\nU+2022 BULLET characters (•).\n\nDefaults to false."
      },
      {
        "name": "maxLines",
        "type": "int",
        "named": true,
        "docs": "The maximum number of lines for the text to span, wrapping if necessary.\nIf this is 1 (the default), the text will not wrap, but will scroll\nhorizontally instead."
      },
      {
        "name": "autofocus",
        "type": "bool",
        "named": true,
        "docs": "Whether this input field should focus itself if nothing else is already focused.\n\nDefaults to false."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "docs": "Called when the text being edited changes.\n\nThe [value] must be updated each time [onChanged] is invoked."
      },
      {
        "name": "onSubmitted",
        "type": "ValueChanged",
        "named": true,
        "docs": "Called when the user indicates that they are done editing the text in the field."
      }
    ]
  },
  "IntrinsicHeight": {
    "name": "IntrinsicHeight",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that sizes its child to the child's intrinsic height.\n\nThis class is useful, for example, when unlimited height is available and\nyou would like a child that would otherwise attempt to expand infinitely to\ninstead size itself to a more reasonable height.\n\nThis class is relatively expensive. Avoid using it where possible.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "IntrinsicWidth": {
    "name": "IntrinsicWidth",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that sizes its child to the child's intrinsic width.\n\nSizes its child's width to the child's maximum intrinsic width. If\n[stepWidth] is non-null, the child's width will be snapped to a multiple of\nthe [stepWidth]. Similarly, if [stepHeight] is non-null, the child's height\nwill be snapped to a multiple of the [stepHeight].\n\nThis class is useful, for example, when unlimited width is available and\nyou would like a child that would otherwise attempt to expand infinitely to\ninstead size itself to a more reasonable width.\n\nThis class is relatively expensive. Avoid using it where possible.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "stepWidth",
        "type": "double",
        "named": true,
        "docs": "If non-null, force the child's width to be a multiple of this value."
      },
      {
        "name": "stepHeight",
        "type": "double",
        "named": true,
        "docs": "If non-null, force the child's height to be a multiple of this value."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "KeyedSubtree": {
    "name": "KeyedSubtree",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A widget that builds its child.\n\nUseful for attaching a key to an existing widget.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "LayoutBuilder": {
    "name": "LayoutBuilder",
    "package": "widgets",
    "parent": "RenderObjectWidget",
    "docs": "Builds a widget tree that can depend on the parent widget's size.\n\nSimilar to the [Builder] widget except that the framework calls the [builder]\nfunction at layout time and provides the parent widget's constraints. This\nis useful when the parent constrains the child's size and doesn't depend on\nthe child's intrinsic size. The LayoutBuilder's final size will match its\nchild's size.\n\nIf the child should be smaller than the parent, consider wrapping the child\nin an [Align] widget. If the child might want to be bigger, consider\nwrapping it in a [ScrollableViewport].\n\nSee also:\n\n* [Builder], which calls a `builder` function at build time.\n* [StatefulBuilder], which passes its `builder` function a `setState` callback.\n* [CustomSingleChildLayout], which positions its child during layout.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "builder",
        "type": "LayoutWidgetBuilder",
        "named": true,
        "required": true,
        "docs": "Called at layout time to construct the widget tree. The builder must not\nreturn null."
      }
    ]
  },
  "LayoutId": {
    "name": "LayoutId",
    "package": "widgets",
    "parent": "ParentDataWidget",
    "docs": "Meta data for identifying children in a [CustomMultiChildLayout].\n\nThe [MultiChildLayoutDelegate] hasChild, layoutChild, and positionChild\nmethods use these identifiers.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "id",
        "type": "Object",
        "named": true,
        "required": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "LeafRenderObjectWidget": {
    "name": "LeafRenderObjectWidget",
    "package": "widgets",
    "parent": "RenderObjectWidget",
    "abstract": true,
    "docs": "A superclass for RenderObjectWidgets that configure RenderObject subclasses\nthat have no children.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      }
    ]
  },
  "LicensePage": {
    "name": "LicensePage",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A page that shows licenses for software used by the application.\n\nTo show a [LicensePage], use [showLicensePage].\n\nThe [AboutDialog] shown by [showAboutDialog] and [AboutDrawerItem] includes\na button that calls [showLicensePage].\n\nThe licenses shown on the [LicensePage] are those returned by the\n[LicenseRegistry] API, which can be used to add more licenses to the list.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "applicationName",
        "type": "String",
        "named": true,
        "docs": "The name of the application.\n\nDefaults to the value of [Title.title], if a [Title] widget can be found.\nOtherwise, defaults to [Platform.resolvedExecutable]."
      },
      {
        "name": "applicationVersion",
        "type": "String",
        "named": true,
        "docs": "The version of this build of the application.\n\nThis string is shown under the application name.\n\nDefaults to the empty string."
      },
      {
        "name": "applicationLegalese",
        "type": "String",
        "named": true,
        "docs": "A string to show in small print.\n\nTypically this is a copyright notice.\n\nDefaults to the empty string."
      }
    ]
  },
  "LimitedBox": {
    "name": "LimitedBox",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A box that limits its size only when it's unconstrained.\n\nIf this widget's maximum width is unconstrained then its child's width is\nlimited to maxWidth. Similarly, if this widget's maximum height is unconstrained\nthen its child's height is limited to to maxHeight.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "maxWidth",
        "type": "double",
        "named": true,
        "docs": "The maximum width limit to apply in the absence of a maxWidth constraint."
      },
      {
        "name": "maxHeight",
        "type": "double",
        "named": true,
        "docs": "The maximum height limit to apply in the absence of a maxHeight constraint."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "LinearProgressIndicator": {
    "name": "LinearProgressIndicator",
    "package": "material",
    "parent": "ProgressIndicator",
    "docs": "A material design linear progress indicator.\n\nA widget that shows progress along a line. There are two kinds of linear\nprogress indicators:\n\n* _Determinate_. Determinate progress indicators have a specific value at\neach point in time, and the value should increase monotonically from 0.0\nto 1.0, at which time the indicator is complete. To create a determinate\nprogress indicator, use a non-null [value] between 0.0 and 1.0.\n* _Indeterminate_. Indeterminate progress indicators do not have a specific\nvalue at each point in time and instead indicate that progress is being\nmade without indicating how much progress remains. To create an\nindeterminate progress indicator, use a null [value].\n\nSee also:\n\n* [CircularProgressIndicator]\n* <https://material.google.com/components/progress-activity.html#progress-activity-types-of-indicators>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "double",
        "named": true
      }
    ]
  },
  "ListItem": {
    "name": "ListItem",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A single row typically containing an icon and some text.\n\nList items are one to three lines of text optionally flanked by icons or\nother widgets, such as check boxes. The icons (or other widgets) for the\nitem are defined with the [leading] and [trailing] parameters. The first\nline of text is not optional and is specified with [title]. The value of\n[subtitle], which _is_ optional, will occupy the space allocated for an\nadditional line of text, or two lines if [isThreeLine] is true. If [dense]\nis true then the overall height of this list item and the size of the\n[DefaultTextStyle]s that wrap the [title] and [subtitle] widget are reduced.\n\nList items are always a fixed height (which height depends on how\n[isThreeLine], [dense], and [subtitle] are configured); they do not grow in\nheight based on their contents. If you are looking for a widget that allows\nfor arbitrary layout in a row, consider [Row].\n\nList items are typically used in [MaterialList]s or in [Card]s.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [ListView], which takes a list of [ListItem] widgets and shows them\nas a scrolling list.\n* [Card], which can be used with [Column] to show a few [ListItem]s.\n* [CircleAvatar], which shows an icon representing a person.\n* [Divider], which can be used to separate [ListItem]s.\n* [ListItem.divideItems], another way to separate [ListItem]s.\n* <https://material.google.com/components/lists.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "leading",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display before the title.\n\nTypically a [CircleAvatar] widget."
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "docs": "The primary content of the list item.\n\nTypically a [Text] widget."
      },
      {
        "name": "subtitle",
        "type": "Widget",
        "named": true,
        "docs": "Additional content displayed below the title.\n\nTypically a [Text] widget."
      },
      {
        "name": "trailing",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display after the title.\n\nTypically an [Icon] widget."
      },
      {
        "name": "isThreeLine",
        "type": "bool",
        "named": true,
        "docs": "Whether this list item is intended to display three lines of text.\n\nIf false, the list item is treated as having one line if the subtitle is\nnull and treated as having two lines if the subtitle is non-null."
      },
      {
        "name": "dense",
        "type": "bool",
        "named": true,
        "docs": "Whether this list item is part of a vertically dense list."
      },
      {
        "name": "enabled",
        "type": "bool",
        "named": true,
        "docs": "Whether this list item is interactive.\n\nIf false, this list item is styled with the disabled color from the\ncurrent [Theme] and the [onTap] and [onLongPress] callbacks are\ninoperative."
      },
      {
        "name": "onTap",
        "type": "GestureTapCallback",
        "named": true,
        "docs": "Called when the user taps this list item.\n\nInoperative if [enabled] is false."
      },
      {
        "name": "onLongPress",
        "type": "GestureLongPressCallback",
        "named": true,
        "docs": "Called when the user long-presses on this list item.\n\nInoperative if [enabled] is false."
      }
    ]
  },
  "ListView": {
    "name": "ListView",
    "package": "widgets",
    "parent": "BoxScrollView",
    "docs": "A scrollable list of boxes.\n\nSee also:\n\n* [SingleChildScrollView], when you need to make a single child scrollable.\n* [GridView], for a scrollable grid of boxes.\n* [PageView], for a scrollable that works page by page.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "scrollDirection",
        "type": "Axis",
        "named": true
      },
      {
        "name": "reverse",
        "type": "bool",
        "named": true
      },
      {
        "name": "controller",
        "type": "ScrollController",
        "named": true
      },
      {
        "name": "primary",
        "type": "bool",
        "named": true
      },
      {
        "name": "physics",
        "type": "ScrollPhysics",
        "named": true
      },
      {
        "name": "shrinkWrap",
        "type": "bool",
        "named": true
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true
      },
      {
        "name": "itemExtent",
        "type": "double",
        "named": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "Listener": {
    "name": "Listener",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that calls callbacks in response to pointer events.\n\nRather than listening for raw pointer events, consider listening for\nhigher-level gestures using [GestureDetector].\n\nIf it has a child, this widget defers to the child for sizing behavior. If\nit does not have a child, it grows to fit the parent instead.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "onPointerDown",
        "type": "PointerDownEventListener",
        "named": true,
        "docs": "Called when a pointer comes into contact with the screen at this object."
      },
      {
        "name": "onPointerMove",
        "type": "PointerMoveEventListener",
        "named": true,
        "docs": "Called when a pointer that triggered an [onPointerDown] changes position."
      },
      {
        "name": "onPointerUp",
        "type": "PointerUpEventListener",
        "named": true,
        "docs": "Called when a pointer that triggered an [onPointerDown] is no longer in contact with the screen."
      },
      {
        "name": "onPointerCancel",
        "type": "PointerCancelEventListener",
        "named": true,
        "docs": "Called when the input from a pointer that triggered an [onPointerDown] is no longer directed towards this receiver."
      },
      {
        "name": "behavior",
        "type": "HitTestBehavior",
        "named": true,
        "docs": "How to behave during hit testing."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "LocaleQuery": {
    "name": "LocaleQuery",
    "package": "widgets",
    "parent": "InheritedWidget",
    "docs": "Establishes a subtree in which locale queries resolve to the given data.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "data",
        "type": "LocaleQueryData",
        "named": true,
        "required": true,
        "docs": "The locale data for this subtree."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "LongPressDraggable": {
    "name": "LongPressDraggable",
    "package": "widgets",
    "parent": "Draggable",
    "docs": "Makes its child draggable starting from long press.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      },
      {
        "name": "feedback",
        "type": "Widget",
        "named": true,
        "required": true
      },
      {
        "name": "data",
        "type": "T",
        "named": true
      },
      {
        "name": "childWhenDragging",
        "type": "Widget",
        "named": true
      },
      {
        "name": "feedbackOffset",
        "type": "dynamic",
        "named": true
      },
      {
        "name": "dragAnchor",
        "type": "DragAnchor",
        "named": true
      },
      {
        "name": "maxSimultaneousDrags",
        "type": "int",
        "named": true
      },
      {
        "name": "onDragStarted",
        "type": "dynamic",
        "named": true
      },
      {
        "name": "onDraggableCanceled",
        "type": "DraggableCanceledCallback",
        "named": true
      }
    ]
  },
  "Material": {
    "name": "Material",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A piece of material.\n\nMaterial is the central metaphor in material design. Each piece of material\nexists at a given elevation, which influences how that piece of material\nvisually relates to other pieces of material and how that material casts\nshadows.\n\nMost user interface elements are either conceptually printed on a piece of\nmaterial or themselves made of material. Material reacts to user input using\n[InkSplash] and [InkHighlight] effects. To trigger a reaction on the\nmaterial, use a [MaterialInkController] obtained via [Material.of].\n\nIf the layout changes (e.g. because there's a list on the paper, and it's\nbeen scrolled), a LayoutChangedNotification must be dispatched at the\nrelevant subtree. (This in particular means that Transitions should not be\nplaced inside Material.) Otherwise, in-progress ink features (e.g., ink\nsplashes and ink highlights) won't move to account for the new layout.\n\nIn general, the features of a [Material] should not change over time (e.g. a\n[Material] should not change its [color] or [type]). The one exception is\nthe [elevation], changes to which will be animated.\n\nSee also:\n\n* [MergeableMaterial], a piece of material that can split and remerge.\n* [Card], a wrapper for a [Material] of [type] [MaterialType.card].\n* <https://material.google.com/>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "type",
        "type": "MaterialType",
        "named": true,
        "docs": "The kind of material to show (e.g., card or canvas). This\naffects the shape of the widget, the roundness of its corners if\nthe shape is rectangular, and the default color."
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this material.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 0."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color to paint the material.\n\nMust be opaque. To create a transparent piece of material, use\n[MaterialType.transparency].\n\nBy default, the color is derived from the [type] of material."
      },
      {
        "name": "textStyle",
        "type": "TextStyle",
        "named": true,
        "docs": "The typographical style to use for text within this material."
      },
      {
        "name": "borderRadius",
        "type": "BorderRadius",
        "named": true,
        "docs": "If non-null, the corners of this box are rounded by this [BorderRadius].\nOtherwise, the corners specified for the current [type] of material are\nused.\n\nMust be null if [type] is [MaterialType.circle]."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "MaterialApp": {
    "name": "MaterialApp",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "An application that uses material design.\n\nA convenience widget that wraps a number of widgets that are commonly\nrequired for material design applications. It builds upon a\n[WidgetsApp] by adding material-design specific functionality, such as\n[AnimatedTheme] and [GridPaper]. This widget also configures the top-level\n[Navigator]'s observer to perform [Hero] animations.\n\nSee also:\n\n* [Scaffold], which provides standard app elements like an [AppBar] and a [Drawer].\n* [Navigator], which is used to manage the app's stack of pages.\n* [MaterialPageRoute], which defines an app page that transitions in a material-specific way.\n* [WidgetsApp], which defines the basic app elements but does not depend on the material library.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "title",
        "type": "String",
        "named": true,
        "docs": "A one-line description of this app for use in the window manager."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The primary color to use for the application in the operating system\ninterface.\n\nFor example, on Android this is the color used for the application in the\napplication switcher."
      },
      {
        "name": "theme",
        "type": "ThemeData",
        "named": true,
        "docs": "The colors to use for the application's widgets."
      },
      {
        "name": "home",
        "type": "Widget",
        "named": true,
        "docs": "The widget for the default route of the app\n([Navigator.defaultRouteName], which is `'/'`).\n\nThis is the page that is displayed first when the application is\nstarted normally.\n\nTo be able to directly call [Theme.of], [MediaQuery.of],\n[LocaleQuery.of], etc, in the code sets the [home] argument in\nthe constructor, you can use a [Builder] widget to get a\n[BuildContext].\n\nIf this is not specified, then either the route with name `'/'`\nmust be given in [routes], or the [onGenerateRoute] callback\nmust be able to build a widget for that route."
      },
      {
        "name": "routes",
        "type": "Map",
        "named": true,
        "docs": "The application's top-level routing table.\n\nWhen a named route is pushed with [Navigator.pushNamed], the route name is\nlooked up in this map. If the name is present, the associated\n[WidgetBuilder] is used to construct a [MaterialPageRoute] that performs\nan appropriate transition, including [Hero] animations, to the new route.\n\nIf the app only has one page, then you can specify it using [home] instead.\n\nIf [home] is specified, then it is an error to provide a route\nin this map for the [Navigator.defaultRouteName] route (`'/'`).\n\nIf a route is requested that is not specified in this table (or\nby [home]), then the [onGenerateRoute] callback is called to\nbuild the page instead."
      },
      {
        "name": "initialRoute",
        "type": "String",
        "named": true,
        "docs": "The name of the first route to show.\n\nDefaults to [Window.defaultRouteName]."
      },
      {
        "name": "onGenerateRoute",
        "type": "RouteFactory",
        "named": true,
        "docs": "The route generator callback used when the app is navigated to a\nnamed route."
      },
      {
        "name": "onLocaleChanged",
        "type": "LocaleChangedCallback",
        "named": true,
        "docs": "Callback that is called when the operating system changes the\ncurrent locale."
      },
      {
        "name": "navigatorObservers",
        "type": "List",
        "named": true,
        "docs": "The list of observers for the [Navigator] created for this app."
      },
      {
        "name": "debugShowMaterialGrid",
        "type": "bool",
        "named": true,
        "docs": "Turns on a [GridPaper] overlay that paints a baseline grid\nMaterial apps:\nhttps://material.google.com/layout/metrics-keylines.html\nOnly available in checked mode."
      },
      {
        "name": "showPerformanceOverlay",
        "type": "bool",
        "named": true,
        "docs": "Turns on a performance overlay.\nhttps://flutter.io/debugging/#performanceoverlay"
      },
      {
        "name": "checkerboardRasterCacheImages",
        "type": "bool",
        "named": true,
        "docs": "Turns on checkerboarding of raster cache images."
      },
      {
        "name": "showSemanticsDebugger",
        "type": "bool",
        "named": true,
        "docs": "Turns on an overlay that shows the accessibility information\nreported by the framework."
      },
      {
        "name": "debugShowCheckedModeBanner",
        "type": "bool",
        "named": true,
        "docs": "Turns on a little \"SLOW MODE\" banner in checked mode to indicate\nthat the app is in checked mode. This is on by default (in\nchecked mode), to turn it off, set the constructor argument to\nfalse. In release mode this has no effect.\n\nTo get this banner in your application if you're not using\nWidgetsApp, include a [CheckedModeBanner] widget in your app.\n\nThis banner is intended to deter people from complaining that your\napp is slow when it's in checked mode. In checked mode, Flutter\nenables a large number of expensive diagnostics to aid in\ndevelopment, and so performance in checked mode is not\nrepresentative of what will happen in release mode."
      }
    ]
  },
  "MaterialButton": {
    "name": "MaterialButton",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design button.\n\nRather than using this class directly, consider using [FlatButton] or [RaisedButton].\n\nMaterialButtons whose [onPressed] handler is null will be disabled. To have\nan enabled button, make sure to pass a non-null value for onPressed.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "colorBrightness",
        "type": "Brightness",
        "named": true,
        "docs": "The theme brightness to use for this button.\n\nDefaults to the brightness from [ThemeData.brightness]."
      },
      {
        "name": "textTheme",
        "type": "ButtonTextTheme",
        "named": true,
        "docs": "The color scheme to use for this button's text.\n\nDefaults to the button color from [ButtonTheme]."
      },
      {
        "name": "textColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use for this button's text."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color of the button, as printed on the [Material]."
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this button.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 0."
      },
      {
        "name": "highlightElevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this button when highlighted.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 0."
      },
      {
        "name": "minWidth",
        "type": "double",
        "named": true,
        "docs": "The smallest horizontal extent that the button will occupy.\n\nDefaults to the value from the current [ButtonTheme]."
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "The vertical extent of the button.\n\nDefaults to the value from the current [ButtonTheme]."
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "The amount of space to surround the child inside the bounds of the button.\n\nDefaults to the value from the current [ButtonTheme]."
      },
      {
        "name": "onPressed",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The callback that is called when the button is tapped or otherwise activated.\n\nIf this is set to null, the button will be disabled."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "MediaQuery": {
    "name": "MediaQuery",
    "package": "widgets",
    "parent": "InheritedWidget",
    "docs": "Establishes a subtree in which media queries resolve to the given data.\n\nFor example, to learn the size of the current media (e.g., the window\ncontaining your app), you can read the [MediaQueryData.size] property from\nthe [MediaQueryData] returned by [MediaQuery.of]:\n`MediaQuery.of(context).size`.\n\nQuerying the current media using [MediaQuery.of] will cause your widget to\nrebuild automatically whenever the [MediaQueryData] changes (e.g., if the\nuser rotates their device).",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "data",
        "type": "MediaQueryData",
        "named": true,
        "required": true,
        "docs": "Contains information about the current media.\n\nFor example, the [MediaQueryData.size] property contains the width and\nheight of the current window."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "MergeSemantics": {
    "name": "MergeSemantics",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that merges the semantics of its descendants.\n\nCauses all the semantics of the subtree rooted at this node to be\nmerged into one node in the semantics tree. For example, if you\nhave a widget with a Text node next to a checkbox widget, this\ncould be used to merge the label from the Text node with the\n\"checked\" semantic state of the checkbox into a single node that\nhad both the label and the checked state. Otherwise, the label\nwould be presented as a separate feature than the checkbox, and\nthe user would not be able to be sure that they were related.\n\nBe aware that if two nodes in the subtree have conflicting\nsemantics, the result may be nonsensical. For example, a subtree\nwith a checked checkbox and an unchecked checkbox will be\npresented as checked. All the labels will be merged into a single\nstring (with newlines separating each label from the other). If\nmultiple nodes in the merged subtree can handle semantic gestures,\nthe first one in tree order will be the one to receive the\ncallbacks.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "MergeableMaterial": {
    "name": "MergeableMaterial",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "Displays a list of [MergeableMaterialItem] children. The list contains\n[MaterialSlice] items whose boundaries are either \"merged\" with adjacent\nitems or separated by a [MaterialGap]. The [children] are distributed along\nthe given [mainAxis] in the same way as the children of a [BlockBody]. When\nthe list of children changes, gaps are automatically animated open or closed\nas needed.\n\nTo enable this widget to correlate its list of children with the previous\none, each child must specify a key.\n\nWhen a new gap is added to the list of children the adjacent items are\nanimated apart. Similarly when a gap is removed the adjacent items are\nbrought back together.\n\nWhen a new slice is added or removed, the app is responsible for animating\nthe transition of the slices, while the gaps will be animated automatically.\n\nSee also:\n\n* [Card], a piece of material that does not support splitting and merging\nbut otherwise looks the same.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "mainAxis",
        "type": "Axis",
        "named": true,
        "docs": "The main layout axis."
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place all the [Material] slices.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 2, the appropriate elevation for cards."
      },
      {
        "name": "hasDividers",
        "type": "bool",
        "named": true,
        "docs": "Whether connected pieces of [MaterialSlice] have dividers between them."
      },
      {
        "name": "children",
        "type": "List",
        "named": true,
        "docs": "The children of the [MergeableMaterial]."
      }
    ]
  },
  "MetaData": {
    "name": "MetaData",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "Holds opaque meta data in the render tree.\n\nUseful for decorating the render tree with information that will be consumed\nlater. For example, you could store information in the render tree that will\nbe used when the user interacts with the render tree but has no visual\nimpact prior to the interaction.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "metaData",
        "type": "dynamic",
        "named": true,
        "docs": "Opaque meta data ignored by the render tree"
      },
      {
        "name": "behavior",
        "type": "HitTestBehavior",
        "named": true,
        "docs": "How to behave during hit testing."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "ModalBarrier": {
    "name": "ModalBarrier",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A widget that prevents the user from interacting with widgets behind itself.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "If non-null, fill the barrier with this color."
      },
      {
        "name": "dismissable",
        "type": "bool",
        "named": true,
        "docs": "Whether touching the barrier will pop the current route off the [Navigator]."
      }
    ]
  },
  "MonthPicker": {
    "name": "MonthPicker",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A scrollable list of months to allow picking a month.\n\nShows the days of each month in a rectangular grid with one column for each\nday of the week.\n\nThe month picker widget is rarely used directly. Instead, consider using\n[showDatePicker], which creates a date picker dialog.\n\nSee also:\n\n* [showDatePicker]\n* <https://material.google.com/components/pickers.html#pickers-date-pickers>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "selectedDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The currently selected date.\n\nThis date is highlighted in the picker."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the user picks a month."
      },
      {
        "name": "firstDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The earliest date the user is permitted to pick."
      },
      {
        "name": "lastDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The latest date the user is permitted to pick."
      },
      {
        "name": "selectableDayPredicate",
        "type": "SelectableDayPredicate",
        "named": true,
        "docs": "Optional user supplied predicate function to customize selectable days."
      }
    ]
  },
  "MultiChildRenderObjectWidget": {
    "name": "MultiChildRenderObjectWidget",
    "package": "widgets",
    "parent": "RenderObjectWidget",
    "abstract": true,
    "docs": "A superclass for RenderObjectWidgets that configure RenderObject subclasses\nthat have a single list of children. (This superclass only provides the\nstorage for that child list, it doesn't actually provide the updating\nlogic.)",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true,
        "docs": "The widgets below this widget in the tree.\n\nIf this list is going to be mutated, it is usually wise to put [Key]s on\nthe widgets, so that the framework can match old configurations to new\nconfigurations and maintain the underlying render objects."
      }
    ]
  },
  "Navigator": {
    "name": "Navigator",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that manages a set of child widgets with a stack discipline.\n\nMany apps have a navigator near the top of their widget hierarchy in order\nto display their logical history using an [Overlay] with the most recently\nvisited pages visually on top of the older pages. Using this pattern lets\nthe navigator visually transition from one page to another by moving the widgets\naround in the overlay. Similarly, the navigator can be used to show a dialog\nby positioning the dialog widget above the current page.\n\n## Using the Navigator\n\nMobile apps typically reveal their contents via full-screen elements\ncalled \"screens\" or \"pages\". In Flutter these elements are called\nroutes and they're managed by a [Navigator] widget. The navigator\nmanages a stack of [Route] objects and provides methods for managing\nthe stack, like [Navigator.push] and [Navigator.pop].\n\n### Displaying a full-screen route\n\nAlthough you can create a navigator directly, it's most common to use\nthe navigator created by a [WidgetsApp] or a [MaterialApp] widget. You\ncan refer to that navigator with [Navigator.of].\n\nA MaterialApp is the simplest way to set things up. The MaterialApp's\nhome becomes the route at the bottom of the Navigator's stack. It is\nwhat you see when the app is launched.\n\n```dart\nvoid main() {\nrunApp(new MaterialApp(home: new MyAppHome()));\n}\n```\n\nTo push a new route on the stack you can create an instance of\n[MaterialPageRoute] with a builder function that creates whatever you\nwant to appear on the screen. For example:\n\n```dart\nNavigator.of(context).push(new MaterialPageRoute<Null>(\nbuilder: (BuildContext context) {\nreturn new Scaffold(\nappBar: new AppBar(title: new Text('My Page')),\nbody: new Center(\nchild: new FlatButton(\nchild: new Text('POP'),\nonPressed: () {\nNavigator.of(context).pop();\n},\n),\n),\n);\n},\n));\n```\n\nThe route defines its widget with a builder function instead of a\nchild widget because it will be built and rebuilt in different\ncontexts depending on when it's pushed and popped.\n\nAs you can see, the new route can be popped, revealing the app's home\npage, with the Navigator's pop method:\n\n```dart\nNavigator.of(context).pop();\n```\n\nIt usually isn't necessary to provide a widget that pops the Navigator\nin a route with a Scaffold because the Scaffold automatically adds a\n'back' button to its AppBar. Pressing the back button causes\n[Navigator.pop] to be called. On Android, pressing the system back\nbutton does the same thing.\n\n### Using named navigator routes\n\nMobile apps often manage a large number of routes and it's often\neasiest to refer to them by name. The [MaterialApp] can be created\nwith a `Map<String, WidgetBuilder>` which maps from a route's name to\na builder function that will create it. The [MaterialApp] uses this\nmap to create a value for its navigator's [onGenerateRoute] callback.\n\n```dart\nvoid main() {\nrunApp(new MaterialApp(\nhome: new MyAppHome(), // becomes the route named '/'\nroutes: <String, WidgetBuilder> {\n'/a': (BuildContext context) => new MyPage(title: 'page A'),\n'/b': (BuildContext context) => new MyPage(title: 'page B'),\n'/c': (BuildContext context) => new MyPage(title: 'page C'),\n},\n));\n}\n```\n\nTo show a route by name:\n```dart\nNavigator.of(context).pushNamed('/b');\n```\n\nThe app's home page route is named '/' by default and other routes are\ngiven pathnames by convention.\n\n### Routes can return a value\n\nWhen a route is pushed to ask the user for a value, the value can be\nreturned via the [pop] method's result parameter.\n\nMethods that push a route return a Future. The Future resolves when\nthe route is popped and the Future's value is the [pop] method's result\nparameter.\n\nFor example if we wanted to ask the user to press 'OK' to confirm an\noperation we could `await` the result of [Navigator.push]:\n\n```\nbool value = await Navigator.of(context).push(new MaterialPageRoute<bool>(\nbuilder: (BuildContext context) {\nreturn new Center(\nchild: new GestureDetector(\nchild: new Text('OK'),\nonTap: () { Navigator.of(context).pop(true); }\n),\n);\n}\n));\n```\nIf the user presses 'OK' then value will be true. If the user backs\nout of the route, for example by pressing the Scaffold's back button,\nthe value will be null.\n\nWhen a route is used to return a value, the route's type parameter\nmust match the type of [pop]'s result. That's why we've used\n`MaterialPageRoute<bool>` instead of `MaterialPageRoute<Null>`.\n\n### Popup routes\n\nRoutes don't have to obscure the entire screen. [PopupRoute]s cover\nthe screen with a barrierColor that can be only partially opaque to\nallow the current screen to show through. Popup routes are \"modal\"\nbecause they block input to the widgets below.\n\nThere are functions which create and show popup routes. For\nexample: [showDialog], [showMenu], and [showBottomSheet]. These\nfunctions return their pushed route's Future as described above.\nCallers can await the returned value to take an action when the\nroute is popped, or to discover the route's value.\n\nThere are also widgets which create popup routes, like [PopupMenuButton] and\n[DropdownButton]. These widgets create internal subclasses of PopupRoute\nand use the Naviagator's push and pop methods to show and dismiss them.\n\n### Custom routes\n\nYou can create your own subclass of one the widget library route classes\nlike [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\ntransition employed to show the route, the color and behavior of the route's\nmodal barrier, and other aspects of the route.\n\nThe PageRouteBuilder class makes it possible to define a custom route\nin terms of callbacks. Here's an example that rotates and fades its child\nwhen the route appears or disappears. This route does not obscure the entire\nscreen because it specifies `opaque: false`, just as a popup route does.\n\n```dart\nNavigator.of(context).push(new PageRouteBuilder(\nopaque: false,\npageBuilder: (BuildContext context, _, __) {\nreturn new Center(child: new Text('My PageRoute'));\n},\ntransitionsBuilder: (_, Animation<double> animation, __, Widget child) {\nreturn new FadeTransition(\nopacity: animation,\nchild: new RotationTransition(\nturns: new Tween<double>(begin: 0.5, end: 1.0).animate(animation),\nchild: child,\n),\n);\n}\n));\n```\nThe page route is built in two parts, the \"page\" and the\n\"transitions\". The page becomes a descendant of the child passed to\nthe `buildTransitions` method. Typically the page is only built once,\nbecause it doesn't depend on its animation parameters (elided with `_`\nand `__` in this example). The transition is built on every frame\nfor its duration.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "initialRoute",
        "type": "String",
        "named": true,
        "docs": "The name of the first route to show."
      },
      {
        "name": "onGenerateRoute",
        "type": "RouteFactory",
        "named": true,
        "required": true,
        "docs": "Called to generate a route for a given [RouteSettings]."
      },
      {
        "name": "onUnknownRoute",
        "type": "RouteFactory",
        "named": true,
        "docs": "Called when [onGenerateRoute] fails to generate a route.\n\nThis callback is typically used for error handling. For example, this\ncallback might always generate a \"not found\" page that describes the route\nthat wasn't found.\n\nUnknown routes can arise either from errors in the app or from external\nrequests to push routes, such as from Android intents."
      },
      {
        "name": "observers",
        "type": "List",
        "named": true,
        "docs": "A list of observers for this navigator."
      }
    ]
  },
  "NotificationListener": {
    "name": "NotificationListener",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A widget that listens for [Notification]s bubbling up the tree.\n\nTo dispatch notifications, use the [Notification.dispatch] method.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "onNotification",
        "type": "NotificationListenerCallback",
        "named": true,
        "docs": "Called when a notification of the appropriate type arrives at this\nlocation in the tree.\n\nReturn true to cancel the notification bubbling. Return false to allow the\nnotification to continue to be dispatched to further ancestors.\n\nThe notification's [Notification.visitAncestor] method is called for each\nancestor, and invokes this callback as appropriate."
      }
    ]
  },
  "Offstage": {
    "name": "Offstage",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that lays the child out as if it was in the tree, but without painting anything,\nwithout making the child available for hit testing, and without taking any\nroom in the parent.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "offstage",
        "type": "bool",
        "named": true,
        "docs": "Whether the child is hidden from the rest of the tree.\n\nIf true, the child is laid out as if it was in the tree, but without\npainting anything, without making the child available for hit testing, and\nwithout taking any room in the parent.\n\nIf false, the child is included in the tree as normal."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Opacity": {
    "name": "Opacity",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that makes its child partially transparent.\n\nThis class paints its child into an intermediate buffer and then blends the\nchild back into the scene partially transparent.\n\nFor values of opacity other than 0.0 and 1.0, this class is relatively\nexpensive because it requires painting the child into an intermediate\nbuffer. For the value 0.0, the child is simply not painted at all. For the\nvalue 1.0, the child is painted immediately without an intermediate buffer.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "opacity",
        "type": "double",
        "named": true,
        "required": true,
        "docs": "The fraction to scale the child's alpha value.\n\nAn opacity of 1.0 is fully opaque. An opacity of 0.0 is fully transparent\n(i.e., invisible).\n\nThe opacity must not be null.\n\nValues 1.0 and 0.0 are painted with a fast path. Other values\nrequire painting the child into an intermediate buffer, which is\nexpensive."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "OrientationBuilder": {
    "name": "OrientationBuilder",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "Builds a widget tree that can depend on the parent widget's orientation.\n\nSee also:\n\n* [LayoutBuilder], which exposes the complete constraints, not just the\norientation.\n* [CustomSingleChildLayout], which positions its child during layout.\n* [CustomMultiChildLayout], with which you can define the precise layout\nof a list of children during the layout phase.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "builder",
        "type": "OrientationWidgetBuilder",
        "named": true,
        "required": true,
        "docs": "Builds the widgets below this widget given this widget's orientation."
      }
    ]
  },
  "OverflowBox": {
    "name": "OverflowBox",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that imposes different constraints on its child than it gets\nfrom its parent, possibly allowing the child to overflow the parent.\n\nSee [RenderOverflowBox] for details.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "How to align the child.\n\nThe x and y values of the alignment control the horizontal and vertical\nalignment, respectively.  An x value of 0.0 means that the left edge of\nthe child is aligned with the left edge of the parent whereas an x value\nof 1.0 means that the right edge of the child is aligned with the right\nedge of the parent. Other values interpolate (and extrapolate) linearly.\nFor example, a value of 0.5 means that the center of the child is aligned\nwith the center of the parent."
      },
      {
        "name": "minWidth",
        "type": "double",
        "named": true,
        "docs": "The minimum width constraint to give the child. Set this to null (the\ndefault) to use the constraint from the parent instead."
      },
      {
        "name": "maxWidth",
        "type": "double",
        "named": true,
        "docs": "The maximum width constraint to give the child. Set this to null (the\ndefault) to use the constraint from the parent instead."
      },
      {
        "name": "minHeight",
        "type": "double",
        "named": true,
        "docs": "The minimum height constraint to give the child. Set this to null (the\ndefault) to use the constraint from the parent instead."
      },
      {
        "name": "maxHeight",
        "type": "double",
        "named": true,
        "docs": "The maximum height constraint to give the child. Set this to null (the\ndefault) to use the constraint from the parent instead."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Overlay": {
    "name": "Overlay",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A [Stack] of entries that can be managed independently.\n\nOverlays let independent child widgets \"float\" visual elements on top of\nother widgets by inserting them into the overlay's [Stack]. The overlay lets\neach of these widgets manage their participation in the overlay using\n[OverlayEntry] objects.\n\nAlthough you can create an [Overlay] directly, it's most common to use the\noverlay created by the [Navigator] in a [WidgetsApp] or a [MaterialApp]. The\nnavigator uses its overlay to manage the visual appearance of its routes.\n\nSee also:\n\n* [OverlayEntry].\n* [OverlayState].\n* [WidgetsApp].\n* [MaterialApp].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "initialEntries",
        "type": "List",
        "named": true,
        "docs": "The entries to include in the overlay initially.\n\nThese entries are only used when the [OverlayState] is initialized. If you\nare providing a new [Overlay] description for an overlay that's already in\nthe tree, then the new entries are ignored.\n\nTo add entries to an [Overlay] that is already in the tree, use\n[Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the\n[Overlay] widget and obtain the [OverlayState] via\n[GlobalKey.currentState]), and then use [OverlayState.add] or\n[OverlayState.addAll].\n\nTo remove an entry from an [Overlay], use [OverlayEntry.remove]."
      }
    ]
  },
  "Padding": {
    "name": "Padding",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that insets its child by the given padding.\n\nWhen passing layout constraints to its child, padding shrinks the\nconstraints by the given padding, causing the child to layout at a smaller\nsize. Padding then sizes itself to its child's size, inflated by the\npadding, effectively creating empty space around the child.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "required": true,
        "docs": "The amount of space by which to inset the child."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "PageStorage": {
    "name": "PageStorage",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A widget that establishes a page storage bucket for this widget subtree.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "bucket",
        "type": "PageStorageBucket",
        "named": true,
        "required": true,
        "docs": "The page storage bucket to use for this subtree."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "PageView": {
    "name": "PageView",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A scrollable list that works page by page.\n\nSee also:\n\n* [SingleChildScrollView], when you need to make a single child scrollable.\n* [ListView], for a scrollable list of boxes.\n* [GridView], for a scrollable grid of boxes.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "scrollDirection",
        "type": "Axis",
        "named": true
      },
      {
        "name": "reverse",
        "type": "bool",
        "named": true
      },
      {
        "name": "controller",
        "type": "PageController",
        "named": true
      },
      {
        "name": "physics",
        "type": "ScrollPhysics",
        "named": true
      },
      {
        "name": "onPageChanged",
        "type": "ValueChanged",
        "named": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "PaginatedDataTable": {
    "name": "PaginatedDataTable",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design data table that shows data using multiple pages.\n\nA paginated data table shows [rowsPerPage] rows of data per page and\nprovies controls for showing other pages.\n\nData is read lazily from from a [DataTableSource]. The widget is presented\nas a [Card].\n\nSee also:\n\n* [DataTable], which is not paginated.\n* <https://material.io/guidelines/components/data-tables.html#data-tables-tables-within-cards>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "header",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The table card's header.\n\nThis is typically a [Text] widget, but can also be a [ButtonBar] with\n[FlatButton]s. Suitable defaults are automatically provided for the font,\nbutton color, button padding, and so forth.\n\nIf items in the table are selectable, then, when the selection is not\nempty, the header is replaced by a count of the selected items."
      },
      {
        "name": "actions",
        "type": "List",
        "named": true,
        "docs": "Icon buttons to show at the top right of the table.\n\nTypically, the exact actions included in this list will vary based on\nwhether any rows are selected or not.\n\nThese should be size 24.0 with default padding (8.0)."
      },
      {
        "name": "columns",
        "type": "List",
        "named": true,
        "docs": "The configuration and labels for the columns in the table."
      },
      {
        "name": "sortColumnIndex",
        "type": "int",
        "named": true,
        "docs": "The current primary sort key's column.\n\nSee [DataTable.sortColumnIndex]."
      },
      {
        "name": "sortAscending",
        "type": "bool",
        "named": true,
        "docs": "Whether the column mentioned in [sortColumnIndex], if any, is sorted\nin ascending order.\n\nSee [DataTable.sortAscending]."
      },
      {
        "name": "onSelectAll",
        "type": "ValueSetter",
        "named": true,
        "docs": "Invoked when the user selects or unselects every row, using the\ncheckbox in the heading row.\n\nSee [DataTable.onSelectAll]."
      },
      {
        "name": "initialFirstRowIndex",
        "type": "int",
        "named": true,
        "docs": "The index of the first row to display when the widget is first created."
      },
      {
        "name": "onPageChanged",
        "type": "ValueChanged",
        "named": true,
        "docs": "Invoked when the user switches to another page.\n\nThe value is the index of the first row on the currently displayed page."
      },
      {
        "name": "rowsPerPage",
        "type": "int",
        "named": true,
        "docs": "The number of rows to show on each page.\n\nSee also:\n\n* [onRowsPerPageChanged]\n* [defaultRowsPerPage]"
      },
      {
        "name": "availableRowsPerPage",
        "type": "List",
        "named": true,
        "docs": "The options to offer for the rowsPerPage.\n\nThe current [rowsPerPage] must be a value in this list.\n\nThe values in this list should be sorted in ascending order."
      },
      {
        "name": "onRowsPerPageChanged",
        "type": "ValueChanged",
        "named": true,
        "docs": "Invoked when the user selects a different number of rows per page.\n\nIf this is null, then the value given by [rowsPerPage] will be used\nand no affordance will be provided to change the value."
      },
      {
        "name": "source",
        "type": "DataTableSource",
        "named": true,
        "required": true,
        "docs": "The data source which provides data to show in each row. Must be non-null.\n\nThis object should generally have a lifetime longer than the\n[PaginatedDataTable] widget itself; it should be reused each time the\n[PaginatedDataTable] constructor is called."
      }
    ]
  },
  "ParentDataWidget": {
    "name": "ParentDataWidget",
    "package": "widgets",
    "parent": "ProxyWidget",
    "abstract": true,
    "docs": "Base class for widgets that hook [ParentData] information to children of\n[RenderObjectWidget]s.\n\nThis can be used to provide per-child configuration for\n[RenderObjectWidget]s with more than one child. For example, [Stack] uses\nthe [Positioned] parent data widget to position each child.\n\nA [ParentDataWidget] is specific to a particular kind of [RenderObject], and\nthus also to a particular [RenderObjectWidget] class. That class is `T`, the\n[ParentDataWidget] type argument.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "PerformanceOverlay": {
    "name": "PerformanceOverlay",
    "package": "widgets",
    "parent": "LeafRenderObjectWidget",
    "docs": "Displays performance statistics.\n\nThe overlay show two time series. The first shows how much time was required\non this thread to produce each frame. The second shows how much time was\nrequired on the GPU thread to produce each frame. Ideally, both these values\nwould be less than the total frame budget for the hardware on which the app\nis running. For example, if the hardware has a screen that updates at 60 Hz,\neach thread should ideally spend less than 16ms producing each frame. This\nideal condition is indicated by a green vertical line for each thread.\nOtherwise, the performance overlay shows a red vertical line.\n\nThe simplest way to show the performance overlay is to set\n[MaterialApp.showPerformanceOverlay] or [WidgetsApp.showPerformanceOverlay]\nto true.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "optionsMask",
        "type": "int",
        "named": true,
        "docs": "The mask is created by shifting 1 by the index of the specific\n[PerformanceOverlayOption] to enable."
      },
      {
        "name": "rasterizerThreshold",
        "type": "int",
        "named": true,
        "docs": "The rasterizer threshold is an integer specifying the number of frame\nintervals that the rasterizer must miss before it decides that the frame\nis suitable for capturing an SkPicture trace for further analysis.\n\nFor example, if you want a trace of all pictures that could not be\nrenderered by the rasterizer within the frame boundary (and hence caused\njank), specify 1. Specifying 2 will trace all pictures that took more\nmore than 2 frame intervals to render. Adjust this value to only capture\nthe particularly expensive pictures while skipping the others. Specifying\n0 disables all capture.\n\nCaptured traces are placed on your device in the application documents\ndirectory in this form \"trace_<collection_time>.skp\". These can\nbe viewed in the Skia debugger.\n\nNotes:\nThe rasterizer only takes into account the time it took to render\nthe already constructed picture. This include the Skia calls (which is\nalso why an SkPicture trace is generated) but not any of the time spent in\ndart to construct that picture. To profile that part of your code, use\nthe instrumentation available in observatory.\n\nTo decide what threshold interval to use, count the number of horizontal\nlines displayed in the performance overlay for the rasterizer (not the\nengine). That should give an idea of how often frames are skipped (and by\nhow many frame intervals)."
      },
      {
        "name": "checkerboardRasterCacheImages",
        "type": "bool",
        "named": true,
        "docs": "Whether the raster cache should checkerboard cached entries.\n\nThe compositor can sometimes decide to cache certain portions of the\nwidget hierarchy. Such portions typically don't change often from frame to\nframe and are expensive to render. This can speed up overall rendering. However,\nthere is certain upfront cost to constructing these cache entries. And, if\nthe cache entries are not used very often, this cost may not be worth the\nspeedup in rendering of subsequent frames. If the developer wants to be certain\nthat populating the raster cache is not causing stutters, this option can be\nset. Depending on the observations made, hints can be provided to the compositor\nthat aid it in making better decisions about caching."
      }
    ]
  },
  "Placeholder": {
    "name": "Placeholder",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget whose child can be mutated.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      }
    ]
  },
  "PopupMenuButton": {
    "name": "PopupMenuButton",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "Displays a menu when pressed and calls [onSelected] when the menu is dismissed\nbecause an item was selected. The value passed to [onSelected] is the value of\nthe selected menu item. If child is null then a standard 'navigation/more_vert'\nicon is created.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "itemBuilder",
        "type": "PopupMenuItemBuilder",
        "named": true,
        "required": true,
        "docs": "Called when the button is pressed to create the items to show in the menu."
      },
      {
        "name": "initialValue",
        "type": "T",
        "named": true,
        "docs": "The value of the menu item, if any, that should be highlighted when the menu opens."
      },
      {
        "name": "onSelected",
        "type": "PopupMenuItemSelected",
        "named": true,
        "docs": "Called when the user selects a value from the popup menu created by this button."
      },
      {
        "name": "tooltip",
        "type": "String",
        "named": true,
        "docs": "Text that describes the action that will occur when the button is pressed.\n\nThis text is displayed when the user long-presses on the button and is\nused for accessibility."
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place the menu when open.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24"
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "Matches IconButton's 8 dps padding by default. In some cases, notably where\nthis button appears as the trailing element of a list item, it's useful to be able\nto set the padding to zero."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "PopupMenuDivider": {
    "name": "PopupMenuDivider",
    "package": "material",
    "parent": "PopupMenuEntry",
    "docs": "A horizontal divider in a material design popup menu.\n\nThis widget adatps the [Divider] for use in popup menus.\n\nSee also:\n\n* [PopupMenuItem]\n* [showMenu]\n* [PopupMenuButton]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "height",
        "type": "double",
        "named": true
      }
    ]
  },
  "PopupMenuEntry": {
    "name": "PopupMenuEntry",
    "package": "material",
    "parent": "StatefulWidget",
    "abstract": true,
    "docs": "A base class for entries in a material design popup menu.\n\nThe popup menu widget uses this interface to interact with the menu items.\nTo show a popup menu, use the [showMenu] function. To create a button that\nshows a popup menu, consider using [PopupMenuButton].\n\nThe type `T` is the type of the value the entry represents. All the entries\nin a given menu must represent values with consistent types.\n\nSee also:\n\n* [PopupMenuItem]\n* [PopupMenuDivider]\n* [CheckedPopupMenuItem]\n* [showMenu]\n* [PopupMenuButton]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      }
    ]
  },
  "PopupMenuItem": {
    "name": "PopupMenuItem",
    "package": "material",
    "parent": "PopupMenuEntry",
    "docs": "An item in a material design popup menu.\n\nTo show a popup menu, use the [showMenu] function. To create a button that\nshows a popup menu, consider using [PopupMenuButton].\n\nTo show a checkmark next to a popup menu item, consider using\n[CheckedPopupMenuItem].\n\nSee also:\n\n* [PopupMenuDivider]\n* [CheckedPopupMenuItem]\n* [showMenu]\n* [PopupMenuButton]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "T",
        "named": true
      },
      {
        "name": "enabled",
        "type": "bool",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "Positioned": {
    "name": "Positioned",
    "package": "widgets",
    "parent": "ParentDataWidget",
    "docs": "A widget that controls where a child of a [Stack] is positioned.\n\nA [Positioned] widget must be a descendant of a [Stack], and the path from\nthe [Positioned] widget to its enclosing [Stack] must contain only\n[StatelessWidget]s or [StatefulWidget]s (not other kinds of widgets, like\n[RenderObjectWidget]s).\n\nIf a widget is wrapped in a [Positioned], then it is a _positioned_ widget\nin its [Stack]. If the [top] property is non-null, the top edge of this child\nwill be positioned [top] layout units from the top of the stack widget. The\n[right], [bottom], and [left] properties work analogously.\n\nIf both the [top] and [bottom] properties are non-null, then the child will\nbe forced to have exactly the height required to satisfy both constraints.\nSimilarly, setting the [right] and [left] properties to non-null values will\nforce the child to have a particular width. Alternatively the [width] and\n[height] properties can be used to give the dimensions, with one\ncorresponding position property (e.g. [top] and [height]).",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "left",
        "type": "double",
        "named": true,
        "docs": "The distance that the child's left edge is inset from the left of the stack.\n\nOnly two out of the three horizontal values ([left], [right], [width]) can be\nset. The third must be null."
      },
      {
        "name": "top",
        "type": "double",
        "named": true,
        "docs": "The distance that the child's top edge is inset from the top of the stack.\n\nOnly two out of the three vertical values ([top], [bottom], [height]) can be\nset. The third must be null."
      },
      {
        "name": "right",
        "type": "double",
        "named": true,
        "docs": "The distance that the child's right edge is inset from the right of the stack.\n\nOnly two out of the three horizontal values ([left], [right], [width]) can be\nset. The third must be null."
      },
      {
        "name": "bottom",
        "type": "double",
        "named": true,
        "docs": "The distance that the child's bottom edge is inset from the bottom of the stack.\n\nOnly two out of the three vertical values ([top], [bottom], [height]) can be\nset. The third must be null."
      },
      {
        "name": "width",
        "type": "double",
        "named": true,
        "docs": "The child's width.\n\nOnly two out of the three horizontal values ([left], [right], [width]) can be\nset. The third must be null."
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "The child's height.\n\nOnly two out of the three vertical values ([top], [bottom], [height]) can be\nset. The third must be null."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "PositionedTransition": {
    "name": "PositionedTransition",
    "package": "widgets",
    "parent": "AnimatedWidget",
    "docs": "Animated version of [Positioned] which takes a specific\n[Animation<RelativeRect>] to transition the child's position from a start\nposition to and end position over the lifetime of the animation.\n\nOnly works if it's the child of a [Stack].\n\nSee also:\n\n* [RelativePositionedTransition].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "rect",
        "type": "Animation",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "PrimaryScrollController": {
    "name": "PrimaryScrollController",
    "package": "widgets",
    "parent": "InheritedWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "controller",
        "type": "ScrollController",
        "named": true,
        "required": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "ProgressIndicator": {
    "name": "ProgressIndicator",
    "package": "material",
    "parent": "StatefulWidget",
    "abstract": true,
    "docs": "A base class for material design progress indicators\n\nThis widget cannot be instantiated directly. For a linear progress\nindicator, see [LinearProgressIndicator]. For a circular progress indicator,\nsee [CircularProgressIndicator].\n\nSee also:\n\n* <https://material.google.com/components/progress-activity.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "double",
        "named": true,
        "docs": "If non-null, the value of this progress indicator with 0.0 corresponding\nto no progress having been made and 1.0 corresponding to all the progress\nhaving been made.\n\nIf null, this progress indicator is indeterminate, which means the\nindicator displays a predetermined animation that does not indicator how\nmuch actual progress is being made."
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The progress indicator's background color. The current theme's\n[ThemeData.backgroundColor] by default."
      },
      {
        "name": "valueColor",
        "type": "Animation",
        "named": true,
        "docs": "The indicator's color is the animation's value. To specify a constant\ncolor use: `new AlwaysStoppedAnimation<Color>(color)`.\n\nIf null, the progress indicator is rendered with the current theme's\n[ThemeData.accentColor]."
      }
    ]
  },
  "ProxyWidget": {
    "name": "ProxyWidget",
    "package": "widgets",
    "parent": "Widget",
    "abstract": true,
    "docs": "A widget that has exactly one child widget.\n\nUseful as a base class for other widgets, such as [InheritedWidget] and\n[ParentDataWidget].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "Radio": {
    "name": "Radio",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design radio button.\n\nUsed to select between a number of mutually exclusive values. When one\nradio button in a group is selected, the other radio buttons in the group\ncease to be selected.\n\nThe radio button itself does not maintain any state. Instead, when the state\nof the radio button changes, the widget calls the [onChanged] callback.\nMost widget that use a radio button will listen for the [onChanged]\ncallback and rebuild the radio button with a new [groupValue] to update the\nvisual appearance of the radio button.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [CheckBox]\n* [Slider]\n* [Switch]\n* <https://material.google.com/components/selection-controls.html#selection-controls-radio-button>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "T",
        "named": true,
        "required": true,
        "docs": "The value represented by this radio button."
      },
      {
        "name": "groupValue",
        "type": "T",
        "named": true,
        "required": true,
        "docs": "The currently selected value for this group of radio buttons.\n\nThis radio button is considered selected if its [value] matches the\n[groupValue]."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the user selects this radio button.\n\nThe radio button passes [value] as a parameter to this callback. The radio\nbutton does not actually change state until the parent widget rebuilds the\nradio button with the new [groupValue].\n\nIf null, the radio button will be displayed as disabled.\n\nThe callback provided to onChanged should update the state of the parent\n[StatefulWidget] using the [State.setState] method, so that the parent\ngets rebuilt; for example:\n\n```dart\nnew Radio<SingingCharacter>(\nvalue: SingingCharacter.lafayette,\ngroupValue: _character,\nonChanged: (SingingCharacter newValue) {\nsetState(() {\n_character = newValue;\n});\n},\n),\n```"
      },
      {
        "name": "activeColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use when this radio button is selected.\n\nDefaults to accent color of the current [Theme]."
      }
    ]
  },
  "RaisedButton": {
    "name": "RaisedButton",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design \"raised button\".\n\nA raised button consists of a rectangular piece of material that hovers over\nthe interface.\n\nUse raised buttons to add dimension to otherwise mostly flat layouts, e.g.\nin long busy lists of content, or in wide spaces. Avoid using raised buttons\non already-raised content such as dialogs or cards.\n\nIf the [onPressed] callback is null, then the button will be disabled and by\ndefault will appear like a flat button in the [disabledColor]. If you are\ntrying to change the button's [color] and it is not having any effect, check\nthat you are passing a non-null [onPressed] handler.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [FlatButton]\n* [DropdownButton]\n* [FloatingActionButton]\n* <https://material.google.com/components/buttons.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "onPressed",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The callback that is called when the button is tapped or otherwise activated.\n\nIf this is set to null, the button will be disabled."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The color of the button, as printed on the [Material]. Defaults to null,\nmeaning that the color is automatically derived from the [Theme].\n\n```dart\nnew RaisedButton(\ncolor: Colors.blue[500],\nonPressed: _handleTap,\nchild: new Text('DEMO'),\n),\n```"
      },
      {
        "name": "disabledColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color of the button when the button is disabled. Buttons are disabled\nby default. To enable a button, set its [onPressed] property to a non-null\nvalue."
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this button.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 2, the appropriate elevation for raised buttons."
      },
      {
        "name": "highlightElevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this button when highlighted.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 8, the appropriate elevation for raised buttons while they are\nbeing touched."
      },
      {
        "name": "disabledElevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this button when disabled.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 0, the appropriate elevation for disabled raised buttons."
      },
      {
        "name": "colorBrightness",
        "type": "Brightness",
        "named": true,
        "docs": "The theme brightness to use for this button.\n\nDefaults to the brightness from [ThemeData.brightness]."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree.\n\nTypically a [Text] widget in all caps."
      }
    ]
  },
  "RawGestureDetector": {
    "name": "RawGestureDetector",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that detects gestures described by the given gesture\nfactories.\n\nFor common gestures, use a [GestureRecognizer].\nRawGestureDetector is useful primarily when developing your\nown gesture recognizers.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "gestures",
        "type": "Map",
        "named": true,
        "docs": "The gestures that this widget will attempt to recognize."
      },
      {
        "name": "behavior",
        "type": "HitTestBehavior",
        "named": true,
        "docs": "How this gesture detector should behave during hit testing."
      },
      {
        "name": "excludeFromSemantics",
        "type": "bool",
        "named": true,
        "docs": "Whether to exclude these gestures from the semantics tree. For\nexample, the long-press gesture for showing a tooltip is\nexcluded because the tooltip itself is included in the semantics\ntree directly and so having a gesture to show it would result in\nduplication of information."
      }
    ]
  },
  "RawImage": {
    "name": "RawImage",
    "package": "widgets",
    "parent": "LeafRenderObjectWidget",
    "docs": "A widget that displays a [ui.Image] directly.\n\nThe image is painted using [paintImage], which describes the meanings of the\nvarious fields on this class in more detail.\n\nThis widget is rarely used directly. Instead, consider using [Image].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "image",
        "type": "dynamic",
        "named": true,
        "docs": "The image to display."
      },
      {
        "name": "width",
        "type": "double",
        "named": true,
        "docs": "If non-null, require the image to have this width.\n\nIf null, the image will pick a size that best preserves its intrinsic\naspect ratio."
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "If non-null, require the image to have this height.\n\nIf null, the image will pick a size that best preserves its intrinsic\naspect ratio."
      },
      {
        "name": "scale",
        "type": "double",
        "named": true,
        "docs": "Specifies the image's scale.\n\nUsed when determining the best display size for the image."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "If non-null, apply this color filter to the image before painting."
      },
      {
        "name": "fit",
        "type": "ImageFit",
        "named": true,
        "docs": "How to inscribe the image into the space allocated during layout.\n\nThe default varies based on the other fields. See the discussion at\n[paintImage]."
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "How to align the image within its bounds.\n\nAn alignment of (0.0, 0.0) aligns the image to the top-left corner of its\nlayout bounds.  An alignment of (1.0, 0.5) aligns the image to the middle\nof the right edge of its layout bounds."
      },
      {
        "name": "repeat",
        "type": "ImageRepeat",
        "named": true,
        "docs": "How to paint any portions of the layout bounds not covered by the image."
      },
      {
        "name": "centerSlice",
        "type": "dynamic",
        "named": true,
        "docs": "The center slice for a nine-patch image.\n\nThe region of the image inside the center slice will be stretched both\nhorizontally and vertically to fit the image into its destination. The\nregion of the image above and below the center slice will be stretched\nonly horizontally and the region of the image to the left and right of\nthe center slice will be stretched only vertically."
      }
    ]
  },
  "RawKeyboardListener": {
    "name": "RawKeyboardListener",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that calls a callback whenever the user presses or releases a key\non a keyboard.\n\nA [RawKeyboardListener] is useful for listening to raw key events and\nhardware buttons that are represented as keys. Typically used by games and\nother apps that use keyboards for purposes other than text entry.\n\nFor text entry, consider using a [EditableText], which integrates with\non-screen keyboards and input method editors (IMEs).\n\nSee also:\n\n* [EditableText], which should be used instead of this widget for text\nentry.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "focused",
        "type": "bool",
        "named": true,
        "docs": "Whether this widget should actually listen for raw keyboard events.\n\nTypically set to the value returned by [Focus.at] for the [GlobalKey] of\nthe widget that builds the raw keyboard listener."
      },
      {
        "name": "onKey",
        "type": "ValueChanged",
        "named": true,
        "docs": "Called whenever this widget receives a raw keyboard event."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "RefreshIndicator": {
    "name": "RefreshIndicator",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A widget that supports the Material \"swipe to refresh\" idiom.\n\nWhen the child's [Scrollable] descendant overscrolls, an animated circular\nprogress indicator is faded into view. When the scroll ends, if the\nindicator has been dragged far enough for it to become completely opaque,\nthe [onRefresh] callback is called. The callback is expected to update the\nscrollable's contents and then complete the [Future] it returns. The refresh\nindicator disappears after the callback's [Future] has completed.\n\nA [RefreshIndicator] can only be used with a vertical scroll view (the xxxxxxx.\n\nSee also:\n\n* <https://material.google.com/patterns/swipe-to-refresh.html>\n* [RefreshIndicatorState], can be used to programatically show the refresh indicator.\n* [RefreshProgressIndicator].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The refresh indicator will be stacked on top of this child. The indicator\nwill appear when child's Scrollable descendant is over-scrolled."
      },
      {
        "name": "displacement",
        "type": "double",
        "named": true,
        "docs": "The distance from the child's top or bottom edge to where the refresh\nindicator will settle. During the drag that exposes the refresh indicator,\nits actual displacement may significantly exceed this value."
      },
      {
        "name": "onRefresh",
        "type": "RefreshCallback",
        "named": true,
        "docs": "A function that's called when the user has dragged the refresh indicator\nfar enough to demonstrate that they want the app to refresh. The returned\n[Future] must complete when the refresh operation is finished."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "The progress indicator's foreground color. The current theme's\n[ThemeData.accentColor] by default."
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The progress indicator's background color. The current theme's\n[ThemeData.canvasColor] by default."
      }
    ]
  },
  "RefreshProgressIndicator": {
    "name": "RefreshProgressIndicator",
    "package": "material",
    "parent": "CircularProgressIndicator",
    "docs": "An indicator for the progress of refreshing the contents of a widget.\n\nTypically used for swipe-to-refresh interactions. See [RefreshIndicator] for\na complete implementation of swipe-to-refresh driven by a [Scrollable]\nwidget.\n\nSee also:\n\n* [RefreshIndicator]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "double",
        "named": true
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true
      },
      {
        "name": "valueColor",
        "type": "Animation",
        "named": true
      }
    ]
  },
  "RelativePositionedTransition": {
    "name": "RelativePositionedTransition",
    "package": "widgets",
    "parent": "AnimatedWidget",
    "docs": "Animated version of [Positioned] which transitions the child's position\nbased on the value of [rect] relative to a bounding box with the\nspecified [size].\n\nOnly works if it's the child of a [Stack].\n\nSee also:\n\n* [PositionedTransition].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "rect",
        "type": "Animation",
        "named": true,
        "required": true
      },
      {
        "name": "size",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The [Positioned] widget's offsets are relative to a box of this\nsize whose origin is 0,0."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "RenderObjectToWidgetAdapter": {
    "name": "RenderObjectToWidgetAdapter",
    "package": "widgets",
    "parent": "RenderObjectWidget",
    "docs": "A bridge from a [RenderObject] to an [Element] tree.\n\nThe given container is the [RenderObject] that the [Element] tree should be\ninserted into. It must be a [RenderObject] that implements the\n[RenderObjectWithChildMixin] protocol. The type argument `T` is the kind of\n[RenderObject] that the container expects as its child.\n\nUsed by [runApp] to bootstrap applications.",
    "properties": [
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "container",
        "type": "RenderObjectWithChildMixin",
        "named": true
      },
      {
        "name": "debugShortDescription",
        "type": "String",
        "named": true,
        "docs": "A short description of this widget used by debugging aids."
      }
    ]
  },
  "RenderObjectWidget": {
    "name": "RenderObjectWidget",
    "package": "widgets",
    "parent": "Widget",
    "abstract": true,
    "docs": "RenderObjectWidgets provide the configuration for [RenderObjectElement]s,\nwhich wrap [RenderObject]s, which provide the actual rendering of the\napplication.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      }
    ]
  },
  "RepaintBoundary": {
    "name": "RepaintBoundary",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that creates a separate display list for its child.\n\nThis widget creates a separate display list for its child, which\ncan improve performance if the subtree repaints at different times than\nthe surrounding parts of the tree. Specifically, when the child does not\nrepaint but its parent does, we can re-use the display list we recorded\npreviously. Similarly, when the child repaints but the surround tree does\nnot, we can re-record its display list without re-recording the display list\nfor the surround tree.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "RichText": {
    "name": "RichText",
    "package": "widgets",
    "parent": "LeafRenderObjectWidget",
    "docs": "A paragraph of rich text.\n\nThe [RichText] widget displays text that uses multiple different styles. The\ntext to display is described using a tree of [TextSpan] objects, each of\nwhich has an associated style that is used for that subtree. The text might\nbreak across multiple lines or might all be displayed on the same line\ndepending on the layout constraints.\n\nText displayed in a [RichText] widget must be explicitly styled. When\npicking which style to use, consider using [DefaultTextStyle.of] the current\n[BuildContext] to provide defaults.\n\nWhen all the text uses the same style, consider using the [Text] widget,\nwhich is less verbose and integrates with [DefaultTextStyle] for default\nstyling.\n\nExample:\n\n```dart\nnew RichText(\ntext: new TextSpan(\ntext: 'Hello ',\nstyle: DefaultTextStyle.of(context).style,\nchildren: <TextSpan>[\nnew TextSpan(text: 'bold', style: new TextStyle(fontWeight: FontWeight.bold)),\nnew TextSpan(text: ' world!'),\n],\n),\n),\n```\n\nSee also:\n\n* [Text]\n* [TextSpan]\n* [DefaultTextStyle]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "text",
        "type": "TextSpan",
        "named": true,
        "required": true,
        "docs": "The text to display in this widget."
      },
      {
        "name": "textAlign",
        "type": "dynamic",
        "named": true,
        "docs": "How the text should be aligned horizontally."
      },
      {
        "name": "softWrap",
        "type": "bool",
        "named": true,
        "docs": "Whether the text should break at soft line breaks.\n\nIf false, the glyphs in the text will be positioned as if there was unlimited horizontal space."
      },
      {
        "name": "overflow",
        "type": "TextOverflow",
        "named": true,
        "docs": "How visual overflow should be handled."
      },
      {
        "name": "textScaleFactor",
        "type": "double",
        "named": true,
        "docs": "The number of font pixels for each logical pixel.\n\nFor example, if the text scale factor is 1.5, text will be 50% larger than\nthe specified font size."
      },
      {
        "name": "maxLines",
        "type": "int",
        "named": true,
        "docs": "An optional maximum number of lines for the text to span, wrapping if necessary.\nIf the text exceeds the given number of lines, it will be truncated according\nto [overflow]."
      }
    ]
  },
  "RotatedBox": {
    "name": "RotatedBox",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that rotates its child by a integral number of quarter turns.\n\nUnlike [Transform], which applies a transform just prior to painting,\nthis object applies its rotation prior to layout, which means the entire\nrotated box consumes only as much space as required by the rotated child.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "quarterTurns",
        "type": "int",
        "named": true,
        "required": true,
        "docs": "The number of clockwise quarter turns the child should be rotated."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "RotationTransition": {
    "name": "RotationTransition",
    "package": "widgets",
    "parent": "AnimatedWidget",
    "docs": "Animates the rotation of a widget.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "turns",
        "type": "Animation",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "Row": {
    "name": "Row",
    "package": "widgets",
    "parent": "Flex",
    "docs": "A widget that displays its children in a horizontal array.\n\nTo cause a child to expand to fill the available horizontal space, wrap the\nchild in an [Expanded] widget.\n\nThe [Row] widget does not scroll (and in general it is considered an error\nto have more children in a [Row] than will fit in the available room). If\nyou have a line of widgets and want them to be able to scroll if there is\ninsufficient room, consider using a [ScrollList].\n\nFor a vertical variant, see [Column].\n\nIf you only have one child, then consider using [Align] or [Center] to\nposition the child.\n\n## Layout algorithm\n\nLayout for a [Row] proceeds in six steps:\n\n1. Layout each child a null or zero flex factor (e.g., those that are not\n[Expanded]) with unbounded horizontal constraints and the incoming\nvertical constraints. If the [crossAxisAlignment] is\n[CrossAxisAlignment.stretch], instead use tight vertical constraints that\nmatch the incoming max height.\n2. Divide the remaining horizontal space among the children with non-zero\nflex factors (e.g., those that are [Expanded]) according to their flex\nfactor. For example, a child with a flex factor of 2.0 will receive twice\nthe amount of horizontal space as a child with a flex factor of 1.0.\n3. Layout each of the remaining children with the same vertical constraints\nas in step 1, but instead of using unbounded horizontal constraints, use\nhorizontal constraints based on the amount of space allocated in step 2.\nChildren with [Flexible.fit] properties that are [FlexFit.tight] are\ngiven tight constraints (i.e., forced to fill the allocated space), and\nchildren with [Flexible.fit] properties that are [FlexFit.loose] are\ngiven loose constraints (i.e., not forced to fill the allocated space).\n4. The height of the [Row] is the maximum height of the children (which will\nalways satisfy the incoming vertical constraints).\n5. The width of the [Row] is determined by the [mainAxisSize] property. If\nthe [mainAxisSize] property is [MainAxisSize.max], then the width of the\n[Row] is the max width of the incoming constraints. If the [mainAxisSize]\nproperty is [MainAxisSize.min], then the width of the [Row] is the sum\nof widths of the children (subject to the incoming constraints).\n6. Determine the position for each child according to the\n[mainAxisAlignment] and the [crossAxisAlignment]. For example, if the\n[mainAxisAlignment] is [MainAxisAlignment.spaceBetween], any horizontal\nspace that has not been allocated to children is divided evenly and\nplaced between the children.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "mainAxisAlignment",
        "type": "MainAxisAlignment",
        "named": true
      },
      {
        "name": "mainAxisSize",
        "type": "MainAxisSize",
        "named": true
      },
      {
        "name": "crossAxisAlignment",
        "type": "CrossAxisAlignment",
        "named": true
      },
      {
        "name": "textBaseline",
        "type": "dynamic",
        "named": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "Scaffold": {
    "name": "Scaffold",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "Implements the basic material design visual layout structure.\n\nThis class provides APIs for showing drawers, snack bars, and bottom sheets.\n\nTo display a snackbar or a persistent bottom sheet, obtain the\n[ScaffoldState] for the current [BuildContext] via [Scaffold.of] and use the\n[ScaffoldState.showSnackBar] and [ScaffoldState.showBottomSheet] functions.\n\nSee also:\n\n* [AppBar], which is a horizontal bar typically shown at the top of an app\nusing the [appBar] property.\n* [FloatingActionButton], which is a circular button typically shown in the\nbottom right corner of the app using the [floatingActionButton] property.\n* [Drawer], which is a vertical panel that is typically displayed to the\nleft of the body (and often hidden on phones) using the [drawer]\nproperty.\n* [BottomNavigationBar], which is a horizontal array of buttons typically\nshown along the bottom of the app using the [bottomNavigationBar]\nproperty.\n* [SnackBar], which is a temporary notification typically shown near the\nbottom of the app using the [ScaffoldState.showSnackBar] method.\n* [BottomSheet], which is an overlay typically shown near the bottom of the\napp. A bottom sheet can either be persistent, in which case it is shown\nusing the [ScaffoldState.showBottomSheet] method, or modal, in which case\nit is shown using the [showModalBottomSheet] function.\n* [ScaffoldState], which is the state associated with this widget.\n* <https://material.google.com/layout/structure.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "appBar",
        "type": "AppBar",
        "named": true,
        "docs": "An app bar to display at the top of the scaffold."
      },
      {
        "name": "body",
        "type": "Widget",
        "named": true,
        "docs": "The primary content of the scaffold.\n\nDisplayed below the app bar and behind the [floatingActionButton] and\n[drawer]. To avoid the body being resized to avoid the window padding\n(e.g., from the onscreen keyboard), see [resizeToAvoidBottomPadding].\n\nThe widget in the body of the scaffold is positioned at the top-left of\nthe available space between the app bar and the bottom of the scaffold. To\ncenter this widget instead, consider putting it in a [Center] widget and\nhaving that be the body. To expand this widget instead, consider\nputting it in a [SizedBox.expand].\n\nIf you have a column of widgets that should normally fit on the screen,\nbut may overflow and would in such cases need to scroll, consider using a\n[ScrollList] as the body of the scaffold. This is also a good choice for\nthe case where your body is a scrollable list."
      },
      {
        "name": "floatingActionButton",
        "type": "Widget",
        "named": true,
        "docs": "A button displayed floating above [body], in the bottom right corner.\n\nTypically a [FloatingActionButton]."
      },
      {
        "name": "persistentFooterButtons",
        "type": "List",
        "named": true,
        "docs": "A set of buttons that are displayed at the bottom of the scaffold.\n\nTypically this is a list of [FlatButton] widgets. These buttons are\npersistently visible, even of the [body] of the scaffold scrolls.\n\nThese widgets will be wrapped in a [ButtonBar].\n\nSee also:\n\n* <https://material.google.com/components/buttons.html#buttons-persistent-footer-buttons>"
      },
      {
        "name": "drawer",
        "type": "Widget",
        "named": true,
        "docs": "A panel displayed to the side of the [body], often hidden on mobile\ndevices.\n\nIn the uncommon case that you wish to open the drawer manually, use the\n[ScaffoldState.openDrawer] function.\n\nTypically a [Drawer]."
      },
      {
        "name": "bottomNavigationBar",
        "type": "Widget",
        "named": true,
        "docs": "A bottom navigation bar to display at the bottom of the scaffold.\n\nSnack bars slide from underneath the bottom navigation bar while bottom\nsheets are stacked on top."
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color of the [Material] widget that underlies the entire Scaffold.\n\nThe theme's [ThemeData.scaffoldBackgroundColor] by default."
      },
      {
        "name": "resizeToAvoidBottomPadding",
        "type": "bool",
        "named": true,
        "docs": "Whether the [body] (and other floating widgets) should size themselves to\navoid the window's bottom padding.\n\nFor example, if there is an onscreen keyboard displayed above the\nscaffold, the body can be resized to avoid overlapping the keyboard, which\nprevents widgets inside the body from being obscured by the keyboard.\n\nDefaults to true."
      }
    ]
  },
  "ScaleTransition": {
    "name": "ScaleTransition",
    "package": "widgets",
    "parent": "AnimatedWidget",
    "docs": "Animates the scale of transformed widget.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "scale",
        "type": "Animation",
        "named": true
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "The alignment of the origin of the coordainte system in which the scale\ntakes place, relative to the size of the box.\n\nFor example, to set the origin of the scale to bottom middle, you can use\nan alignment of (0.5, 1.0)."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "ScrollConfiguration": {
    "name": "ScrollConfiguration",
    "package": "widgets",
    "parent": "InheritedWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "behavior",
        "type": "ScrollBehavior",
        "named": true,
        "required": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "ScrollView": {
    "name": "ScrollView",
    "package": "widgets",
    "parent": "StatelessWidget",
    "abstract": true,
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "scrollDirection",
        "type": "Axis",
        "named": true
      },
      {
        "name": "reverse",
        "type": "bool",
        "named": true
      },
      {
        "name": "controller",
        "type": "ScrollController",
        "named": true
      },
      {
        "name": "primary",
        "type": "bool",
        "named": true
      },
      {
        "name": "physics",
        "type": "ScrollPhysics",
        "named": true
      },
      {
        "name": "shrinkWrap",
        "type": "bool",
        "named": true
      }
    ]
  },
  "Scrollable": {
    "name": "Scrollable",
    "package": "widgets",
    "parent": "StatefulWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "axisDirection",
        "type": "AxisDirection",
        "named": true
      },
      {
        "name": "controller",
        "type": "ScrollController",
        "named": true
      },
      {
        "name": "physics",
        "type": "ScrollPhysics",
        "named": true
      },
      {
        "name": "viewportBuilder",
        "type": "ViewportBuilder",
        "named": true,
        "required": true
      }
    ]
  },
  "Scrollbar": {
    "name": "Scrollbar",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design scrollbar.\n\nA scrollbar indicates which portion of a [Scrollable] widget is actually\nvisible.\n\nTo add a scrollbar to a [ScrollView], simply wrap the scroll view widget in\na [Scrollbar] widget.\n\nSee also:\n\n* [ListView], which display a linear, scrollable list of children.\n* [GridView], which display a 2 dimensional, scrollable array of children.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The subtree to place inside the [Scrollbar].\n\nThis should include a source of [ScrollNotification] notifications,\ntypically a [Scrollable] widget."
      }
    ]
  },
  "Semantics": {
    "name": "Semantics",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that annotates the widget tree with a description of the meaning of\nthe widgets.\n\nUsed by accessibility tools, search engines, and other semantic analysis\nsoftware to determine the meaning of the application.\n\nSee also:\n\n* [MergeSemantics], which marks a subtree as being a single node for\naccessibility purposes.\n* [ExcludeSemantics], which excludes a subtree from the semantics tree\n(which might be useful if it is, e.g., totally decorative and not\nimportant to the user).\n* [RenderObject.semanticsAnnotator], the rendering library API through which\nthe [Semantics] widget is actually implemented.\n* [SemanticsNode], the object used by the rendering library to represent\nsemantics in the semantics tree.\n* [SemanticsDebugger], an overlay to help visualize the semantics tree. Can\nbe enabled using [WidgetsApp.showSemanticsDebugger] or\n[MaterialApp.showSemanticsDebugger].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      },
      {
        "name": "container",
        "type": "bool",
        "named": true,
        "docs": "If 'container' is true, this Widget will introduce a new node in\nthe semantics tree. Otherwise, the semantics will be merged with\nthe semantics of any ancestors.\n\nThe 'container' flag is implicitly set to true on the immediate\nsemantics-providing descendants of a node where multiple\nchildren have semantics or have descendants providing semantics.\nIn other words, the semantics of siblings are not merged. To\nmerge the semantics of an entire subtree, including siblings,\nyou can use a [MergeSemantics] widget."
      },
      {
        "name": "checked",
        "type": "bool",
        "named": true,
        "docs": "If non-null, indicates that this subtree represents a checkbox\nor similar widget with a \"checked\" state, and what its current\nstate is."
      },
      {
        "name": "label",
        "type": "String",
        "named": true,
        "docs": "Provides a textual description of the widget."
      }
    ]
  },
  "SemanticsDebugger": {
    "name": "SemanticsDebugger",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A widget that visualizes the semantics for the child.\n\nThis widget is useful for understand how an app presents itself to\naccessibility technology.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "ShaderMask": {
    "name": "ShaderMask",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that applies a mask generated by a [Shader] to its child.\n\nFor example, [ShaderMask] can be used to gradually fade out the edge\nof a child by using a [ui.Gradient.linear] mask.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "shaderCallback",
        "type": "ShaderCallback",
        "named": true,
        "required": true,
        "docs": "Called to creates the [Shader] that generates the mask.\n\nThe shader callback is called with the current size of the child so that\nit can customize the shader to the size and location of the child."
      },
      {
        "name": "blendMode",
        "type": "dynamic",
        "named": true,
        "docs": "The [BlendMode] to use when applying the shader to the child.\n\nThe default, [BlendMode.modulate], is useful for applying an alpha blend\nto the child. Other blend modes can be used to create other effects."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "ShrinkWrappingViewport": {
    "name": "ShrinkWrappingViewport",
    "package": "widgets",
    "parent": "MultiChildRenderObjectWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "axisDirection",
        "type": "AxisDirection",
        "named": true
      },
      {
        "name": "offset",
        "type": "ViewportOffset",
        "named": true,
        "required": true
      },
      {
        "name": "slivers",
        "type": "List",
        "named": true
      }
    ]
  },
  "SimpleDialog": {
    "name": "SimpleDialog",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A simple material design dialog.\n\nA simple dialog offers the user a choice between several options. A simple\ndialog has an optional title that is displayed above the choices.\n\nFor dialogs that inform the user about a situation, consider using an\n[AlertDialog].\n\nTypically passed as the child widget to [showDialog], which displays the\ndialog.\n\nSee also:\n\n* [SimpleDialogOption], which are options used in this type of dialog.\n* [AlertDialog], for dialogs that have a row of buttons below the body.\n* [Dialog], on which [SimpleDialog] and [AlertDialog] are based.\n* [showDialog], which actually displays the dialog and returns its result.\n* <https://material.google.com/components/dialogs.html#dialogs-simple-dialogs>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "docs": "The (optional) title of the dialog is displayed in a large font at the top\nof the dialog.\n\nTypically a [Text] widget."
      },
      {
        "name": "titlePadding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "Padding around the title.\n\nUses material design default if none is supplied. If there is no title, no\npadding will be provided."
      },
      {
        "name": "children",
        "type": "List",
        "named": true,
        "docs": "The (optional) content of the dialog is displayed in a\n[SingleChildScrollView] underneath the title.\n\nTypically a list of [SimpleDialogOption]s."
      },
      {
        "name": "contentPadding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "Padding around the content.\n\nUses material design default if none is supplied."
      }
    ]
  },
  "SimpleDialogOption": {
    "name": "SimpleDialogOption",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "An option used in a [SimpleDialog].\n\nA simple dialog offers the user a choice between several options. This\nwidget is commonly used to represent each of the options. If the user\nselects this option, the widget will call the [onPressed] callback, which\ntypically uses [Navigator.pop] to close the dialog.\n\nSee also:\n\n* [SimpleDialog], for a dialog in which to use this widget.\n* [showDialog], which actually displays the dialog and returns its result.\n* [FlatButton], which are commonly used as actions in other kinds of\ndialogs, such as [AlertDialog]s.\n* <https://material.google.com/components/dialogs.html#dialogs-simple-dialogs>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "onPressed",
        "type": "dynamic",
        "named": true,
        "docs": "The callback that is called when this option is selected.\n\nIf this is set to null, the option cannot be selected."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree.\n\nTypically a [Text] widget."
      }
    ]
  },
  "SingleChildRenderObjectWidget": {
    "name": "SingleChildRenderObjectWidget",
    "package": "widgets",
    "parent": "RenderObjectWidget",
    "abstract": true,
    "docs": "A superclass for RenderObjectWidgets that configure RenderObject subclasses\nthat have a single child slot. (This superclass only provides the storage\nfor that child, it doesn't actually provide the updating logic.)",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "SingleChildScrollView": {
    "name": "SingleChildScrollView",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A box in which a single widget can be scrolled.\n\nThis widget is useful when you have a single box that will normally be\nentirely visible, for example a clock face in a time picker, but you need to\nmake sure it can be scrolled if the container gets too small in one axis\n(the scroll direction).\n\nIt is also useful if you need to shrink-wrap in both axes (the main\nscrolling direction as well as the cross axis), as one might see in a dialog\nor pop-up menu. In that case, you might pair the [SingleChildScrollView]\nwith a [BlockBody] child.\n\nWhen you have a list of children and do not require cross-axis\nshrink-wrapping behavior, for example a scrolling list that is always the\nwidth of the screen, consider [ListView], which is vastly more efficient\nthat a [SingleChildScrollView] containing a [BlockBody] or [Column] with\nmany children.\n\nSee also:\n\n* [ListView], which handles multiple children in a scrolling list.\n* [GridView], which handles multiple children in a scrolling grid.\n* [PageView], for a scrollable that works page by page.\n* [Scrollable], which handles arbitrary scrolling effects.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "scrollDirection",
        "type": "Axis",
        "named": true
      },
      {
        "name": "reverse",
        "type": "bool",
        "named": true
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true
      },
      {
        "name": "primary",
        "type": "bool",
        "named": true
      },
      {
        "name": "physics",
        "type": "ScrollPhysics",
        "named": true
      },
      {
        "name": "controller",
        "type": "ScrollController",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "SizeChangedLayoutNotifier": {
    "name": "SizeChangedLayoutNotifier",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that automatically dispatches a [SizeChangedLayoutNotifier] when\nthe layout of its child changes.\n\nUseful especially when having some complex, layout-changing animation within\n[Material] that is also interactive.\n\nThe notification is not sent for the initial layout (since the size doesn't\nchange in that case, it's just established).",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "SizeTransition": {
    "name": "SizeTransition",
    "package": "widgets",
    "parent": "AnimatedWidget",
    "docs": "Animates its own size and clips and aligns the child.\n\nFor a widget that automatically animates between the sizes of two children,\nfading between them, see [AnimatedCrossFade].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "axis",
        "type": "Axis",
        "named": true,
        "docs": "[Axis.horizontal] if [sizeFactor] modifies the width, otherwise [Axis.vertical]."
      },
      {
        "name": "sizeFactor",
        "type": "Animation",
        "named": true
      },
      {
        "name": "axisAlignment",
        "type": "double",
        "named": true,
        "docs": "How to align the child along the axis that sizeFactor is modifying."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "SizedBox": {
    "name": "SizedBox",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A box with a specified size.\n\nIf given a child, this widget forces its child to have a specific width\nand/or height (assuming values are permitted by this widget's parent). If\neither the width or height is null, this widget will size itself to match\nthe child's size in that dimension.\n\nIf not given a child, this widget will size itself to the given width and\nheight, treating nulls as zero.\n\nThe [new SizedBox.expand] constructor can be used to make a [SizedBox] that\nsizes itself to fit the parent. It is equivalent to setting [width] and\n[height] to [double.INFINITY].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "width",
        "type": "double",
        "named": true,
        "docs": "If non-null, requires the child to have exactly this width."
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "If non-null, requires the child to have exactly this height."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "SizedOverflowBox": {
    "name": "SizedOverflowBox",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that is a specific size but passes its original constraints\nthrough to its child, which will probably overflow.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "size",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The size this widget should attempt to be."
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "How to align the child.\n\nThe x and y values of the alignment control the horizontal and vertical\nalignment, respectively.  An x value of 0.0 means that the left edge of\nthe child is aligned with the left edge of the parent whereas an x value\nof 1.0 means that the right edge of the child is aligned with the right\nedge of the parent. Other values interpolate (and extrapolate) linearly.\nFor example, a value of 0.5 means that the center of the child is aligned\nwith the center of the parent."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "SlideTransition": {
    "name": "SlideTransition",
    "package": "widgets",
    "parent": "AnimatedWidget",
    "docs": "Animates the position of a widget relative to its normal position.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "position",
        "type": "Animation",
        "named": true
      },
      {
        "name": "transformHitTests",
        "type": "bool",
        "named": true,
        "docs": "Whether hit testing should be affected by the slide animation.\n\nIf false, hit testing will proceed as if the child was not translated at\nall. Setting this value to false is useful for fast animations where you\nexpect the user to commonly interact with the child widget in its final\nlocation and you want the user to benefit from \"muscle memory\"."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "Slider": {
    "name": "Slider",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design slider.\n\nUsed to select from a range of values.\n\nA slider can be used to select from either a continuous or a discrete set of\nvalues. The default is use a continuous range of values from [min] to [max].\nTo use discrete values, use a non-null value for [divisions], which\nindicates the number of discrete intervals. For example, if [min] is 0.0 and\n[max] is 50.0 and [divisions] is 5, then the slider can take on the values\ndiscrete values 0.0, 10.0, 20.0, 30.0, 40.0, and 50.0.\n\nThe slider itself does not maintain any state. Instead, when the state of\nthe slider changes, the widget calls the [onChanged] callback. Most widgets\nthat use a slider will listen for the [onChanged] callback and rebuild the\nslider with a new [value] to update the visual appearance of the slider.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [CheckBox]\n* [Radio]\n* [Switch]\n* <https://material.google.com/components/sliders.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "double",
        "named": true,
        "required": true,
        "docs": "The currently selected value for this slider.\n\nThe slider's thumb is drawn at a position that corresponds to this value."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the user selects a new value for the slider.\n\nThe slider passes the new value to the callback but does not actually\nchange state until the parent widget rebuilds the slider with the new\nvalue.\n\nIf null, the slider will be displayed as disabled.\n\nThe callback provided to onChanged should update the state of the parent\n[StatefulWidget] using the [State.setState] method, so that the parent\ngets rebuilt; for example:\n\n```dart\nnew Slider(\nvalue: _duelCommandment.toDouble(),\nmin: 1.0,\nmax: 10.0,\ndivisions: 10,\nlabel: '$_duelCommandment',\nonChanged: (double newValue) {\nsetState(() {\n_duelCommandment = newValue.round();\n});\n},\n),\n```"
      },
      {
        "name": "min",
        "type": "double",
        "named": true,
        "docs": "The minimum value the user can select.\n\nDefaults to 0.0."
      },
      {
        "name": "max",
        "type": "double",
        "named": true,
        "docs": "The maximum value the user can select.\n\nDefaults to 1.0."
      },
      {
        "name": "divisions",
        "type": "int",
        "named": true,
        "docs": "The number of discrete divisions.\n\nTypically used with [label] to show the current discrete value.\n\nIf null, the slider is continuous."
      },
      {
        "name": "label",
        "type": "String",
        "named": true,
        "docs": "A label to show above the slider when the slider is active.\n\nTypically used to display the value of a discrete slider."
      },
      {
        "name": "activeColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use for the portion of the slider that has been selected.\n\nDefaults to accent color of the current [Theme]."
      },
      {
        "name": "thumbOpenAtMin",
        "type": "bool",
        "named": true,
        "docs": "Whether the thumb should be an open circle when the slider is at its minimum position.\n\nWhen this property is false, the thumb does not change when it the slider\nreaches its minimum position.\n\nThis property is useful, for example, when the minimum value represents a\nqualitatively different state. For a slider that controls the volume of\na sound, for example, the minimum value represents \"no sound at all,\"\nwhich is qualitatively different from even a very soft sound.\n\nDefaults to false."
      }
    ]
  },
  "SliverAppBar": {
    "name": "SliverAppBar",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design app bar that integrates with a [CustomScrollView].\n\nAn app bar consists of a toolbar and potentially other widgets, such as a\n[TabBar] and a [FlexibleSpaceBar]. App bars typically expose one or more\ncommon actions with [IconButton]s which are optionally followed by a\n[PopupMenuButton] for less common operations.\n\nSliver app bars are typically used as the first child of a\n[CustomScrollView], which lets the app bar integrate with the scroll view so\nthat it can vary in height according to the scroll offset or float above the\nother content in the scroll view. For a fixed-height app bar at the top of\nthe screen see [AppBar], which is used in the [Scaffold.appBar] slot.\n\nThe AppBar displays the toolbar widgets, [leading], [title], and\n[actions], above the [bottom] (if any). If a [flexibleSpace] widget is\nspecified then it is stacked behind the toolbar and the bottom widget.\n\nSee also:\n\n* [CustomScrollView], which integrates the [SliverAppBar] into its\nscrolling.\n* [AppBar], which is a fixed-height app bar for use in [Scaffold.appBar].\n* [TabBar], which is typically placed in the [bottom] slot of the [AppBar]\nif the screen has multiple pages arranged in tabs.\n* [IconButton], which is used with [actions] to show buttons on the app bar.\n* [PopupMenuButton], to show a popup menu on the app bar, via [actions].\n* [FlexibleSpaceBar], which is used with [flexibleSpace] when the app bar\ncan expand and collapse.\n* <https://material.google.com/layout/structure.html#structure-toolbars>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "leading",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display before the [title].\n\nIf this is null, the [AppBar] will imply an appropriate widget. For\nexample, if the [AppBar] is in a [Scaffold] that also has a [Drawer], the\n[Scaffold] will fill this widget with an [IconButton] that opens the\ndrawer. If there's no [Drawer] and the parent [Navigator] can go back, the\n[AppBar] will use an [IconButton] that calls [Navigator.pop]."
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "docs": "The primary widget displayed in the appbar.\n\nTypically a [Text] widget containing a description of the current contents\nof the app."
      },
      {
        "name": "actions",
        "type": "List",
        "named": true,
        "docs": "Widgets to display after the [title] widget.\n\nTypically these widgets are [IconButton]s representing common operations.\nFor less common operations, consider using a [PopupMenuButton] as the\nlast action.\n\nFor example:\n\n```dart\nreturn new Scaffold(\nbody: new CustomView(\nprimary: true,\nslivers: <Widget>[\nnew SliverAppBar(\ntitle: new Text('Hello World'),\nactions: <Widget>[\nnew IconButton(\nicon: new Icon(Icons.shopping_cart),\ntooltip: 'Open shopping cart',\nonPressed: _openCart,\n),\n],\n),\n// ...rest of body...\n],\n),\n);\n```"
      },
      {
        "name": "flexibleSpace",
        "type": "Widget",
        "named": true,
        "docs": "This widget is stacked behind the toolbar and the tabbar. It's height will\nbe the same as the the app bar's overall height.\n\nTypically a [FlexibleSpaceBar]. See [FlexibleSpaceBar] for details."
      },
      {
        "name": "bottom",
        "type": "AppBarBottomWidget",
        "named": true,
        "docs": "This widget appears across the bottom of the appbar.\n\nTypically a [TabBar]. This widget must be a widget that implements the\n[AppBarBottomWidget] interface."
      },
      {
        "name": "elevation",
        "type": "int",
        "named": true,
        "docs": "The z-coordinate at which to place this app bar.\n\nThe following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24\n\nDefaults to 4, the appropriate elevation for app bars.\n\nThe elevation is ignored when the app bar has no content underneath it.\nFor example, if the app bar is [pinned] but no content is scrolled under\nit, or if it scrolls with the content."
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use for the app bar's material. Typically this should be set\nalong with [brightness], [iconTheme], [textTheme].\n\nDefaults to [ThemeData.primaryColor]."
      },
      {
        "name": "brightness",
        "type": "Brightness",
        "named": true,
        "docs": "The brightness of the app bar's material. Typically this is set along\nwith [backgroundColor], [iconTheme], [textTheme].\n\nDefaults to [ThemeData.primaryColorBrightness]."
      },
      {
        "name": "iconTheme",
        "type": "IconThemeData",
        "named": true,
        "docs": "The color, opacity, and size to use for app bar icons. Typically this\nis set along with [backgroundColor], [brightness], [textTheme].\n\nDefaults to [ThemeData.primaryIconTheme]."
      },
      {
        "name": "textTheme",
        "type": "TextTheme",
        "named": true,
        "docs": "The typographic styles to use for text in the app bar. Typically this is\nset along with [brightness] [backgroundColor], [iconTheme].\n\nDefaults to [ThemeData.primaryTextTheme]."
      },
      {
        "name": "primary",
        "type": "bool",
        "named": true,
        "docs": "Whether this app bar is being displayed at the top of the screen.\n\nIf this is true, the top padding specified by the [MediaQuery] will be\nadded to the top of the toolbar."
      },
      {
        "name": "centerTitle",
        "type": "bool",
        "named": true,
        "docs": "Whether the title should be centered.\n\nDefaults to being adapted to the current [TargetPlatform]."
      },
      {
        "name": "expandedHeight",
        "type": "double",
        "named": true,
        "docs": "The size of the app bar when it is fully expanded.\n\nBy default, the total height of the toolbar and the bottom widget (if\nany). If a [flexibleSpace] widget is specified this height should be big\nenough to accommodate whatever that widget contains.\n\nThis does not include the status bar height (which will be automatically\nincluded if [primary] is true).\n\nSee also [AppBar.getExpandedHeightFor]."
      },
      {
        "name": "floating",
        "type": "bool",
        "named": true,
        "docs": "Whether the app bar should become visible as soon as the user scrolls\ntowards the app bar.\n\nOtherwise, the user will need to scroll near the top of the scroll view to\nreveal the app bar."
      },
      {
        "name": "pinned",
        "type": "bool",
        "named": true,
        "docs": "Whether the app bar should remain visible at the start of the scroll view.\n\nThe app bar can still expand an contract as the user scrolls, but it will\nremain visible rather than being scrolled out of view."
      }
    ]
  },
  "SliverFill": {
    "name": "SliverFill",
    "package": "widgets",
    "parent": "SliverMultiBoxAdaptorWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "delegate",
        "type": "SliverChildDelegate",
        "named": true,
        "required": true
      }
    ]
  },
  "SliverFixedExtentList": {
    "name": "SliverFixedExtentList",
    "package": "widgets",
    "parent": "SliverMultiBoxAdaptorWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "delegate",
        "type": "SliverChildDelegate",
        "named": true,
        "required": true
      },
      {
        "name": "itemExtent",
        "type": "double",
        "named": true,
        "required": true
      }
    ]
  },
  "SliverGrid": {
    "name": "SliverGrid",
    "package": "widgets",
    "parent": "SliverMultiBoxAdaptorWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "delegate",
        "type": "SliverChildDelegate",
        "named": true,
        "required": true
      },
      {
        "name": "gridDelegate",
        "type": "SliverGridDelegate",
        "named": true,
        "required": true
      }
    ]
  },
  "SliverList": {
    "name": "SliverList",
    "package": "widgets",
    "parent": "SliverMultiBoxAdaptorWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "delegate",
        "type": "SliverChildDelegate",
        "named": true,
        "required": true
      }
    ]
  },
  "SliverMultiBoxAdaptorWidget": {
    "name": "SliverMultiBoxAdaptorWidget",
    "package": "widgets",
    "parent": "RenderObjectWidget",
    "abstract": true,
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "delegate",
        "type": "SliverChildDelegate",
        "named": true,
        "required": true
      }
    ]
  },
  "SliverPadding": {
    "name": "SliverPadding",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "required": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "SliverPersistentHeader": {
    "name": "SliverPersistentHeader",
    "package": "widgets",
    "parent": "StatelessWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "delegate",
        "type": "SliverPersistentHeaderDelegate",
        "named": true,
        "required": true
      },
      {
        "name": "pinned",
        "type": "bool",
        "named": true
      },
      {
        "name": "floating",
        "type": "bool",
        "named": true
      }
    ]
  },
  "SliverToBoxAdapter": {
    "name": "SliverToBoxAdapter",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "SnackBar": {
    "name": "SnackBar",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A lightweight message with an optional action which briefly displays at the\nbottom of the screen.\n\nTo display a snack bar, call `Scaffold.of(context).showSnackBar()`, passing\nan instance of [SnackBar] that describes the message.\n\nTo control how long the [SnackBar] remains visible, specify a [duration].\n\nSee also:\n\n* [Scaffold.of], to obtain the current [ScaffoldState], which manages the\ndisplay and animation of snack bars.\n* [ScaffoldState.showSnackBar], which displays a [SnackBar].\n* [ScaffoldState.removeCurrentSnackBar], which abruptly hides the currently\ndisplayed snack bar, if any, and allows the next to be displayed.\n* [SnackBarAction], which is used to specify an [action] button to show\non the snack bar.\n* <https://material.google.com/components/snackbars-toasts.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "content",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The primary content of the snack bar.\n\nTypically a [Text] widget."
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The Snackbar's background color. By default the color is dark grey."
      },
      {
        "name": "action",
        "type": "SnackBarAction",
        "named": true,
        "docs": "(optional) An action that the user can take based on the snack bar.\n\nFor example, the snack bar might let the user undo the operation that\nprompted the snackbar. Snack bars can have at most one action.\n\nThe action should not be \"dismiss\" or \"cancel\"."
      },
      {
        "name": "duration",
        "type": "Duration",
        "named": true,
        "docs": "The amount of time the snack bar should be displayed.\n\nDefaults to 1.5s.\n\nSee also:\n\n* [ScaffoldState.removeCurrentSnackBar], which abruptly hides the\ncurrently displayed snack bar, if any, and allows the next to be\ndisplayed.\n* <https://material.google.com/components/snackbars-toasts.html>"
      },
      {
        "name": "animation",
        "type": "Animation",
        "named": true,
        "docs": "The animation driving the entrance and exit of the snack bar."
      }
    ]
  },
  "SnackBarAction": {
    "name": "SnackBarAction",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A button for a [SnackBar], known as an \"action\".\n\nSnack bar actions are always enabled. If you want to disable a snack bar\naction, simply don't include it in the snack bar.\n\nSnack bar actions can only be pressed once. Subsequent presses are ignored.\n\nSee also:\n\n* [SnackBar]\n* <https://material.google.com/components/snackbars-toasts.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "label",
        "type": "String",
        "named": true,
        "docs": "The button label."
      },
      {
        "name": "onPressed",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The callback to be called when the button is pressed. Must not be null.\n\nThis callback will be called at most once each time this action is\ndisplayed in a [SnackBar]."
      }
    ]
  },
  "Stack": {
    "name": "Stack",
    "package": "widgets",
    "parent": "MultiChildRenderObjectWidget",
    "docs": "A widget that uses the stack layout algorithm for its children.\n\nThis class is useful if you want to overlap several children in a simple\nway, for example having some text and an image, overlaid with a gradient and\na button attached to the bottom.\n\nEach child of a [Stack] widget is either _positioned_ or _non-positioned_.\nPositioned children are those wrapped in a [Positioned] widget that has at\nleast one non-null property. The stack sizes itself to contain all the\nnon-positioned children, which are positioned according to [alignment]\n(which defaults to the top-left corner). The positioned children are then\nplaced relative to the stack according to their top, right, bottom, and left\nproperties.\n\nThe stack paints its children in order. If you want to change the order in\nwhich the children paint, you can rebuild the stack with the children in\nthe new order. If you reorder the children in this way, consider giving the\nchildren non-null keys. These keys will cause the framework to move the\nunderlying objects for the children to their new locations rather than\nrecreate them at their new location.\n\nFor more details about the stack layout algorithm, see [RenderStack].\n\nIf you want to lay a number of children out in a particular pattern, or if\nyou want to make a custom layout manager, you probably want to use\n[CustomMultiChildLayout] instead. In particular, when using a [Stack] you\ncan't position children relative to their size or the stack's own size.\n\nSee also:\n\n* [Align], which sizes itself based on its child's size and positions\nthe child according to a [FractionalOffset] value.\n* [CustomSingleChildLayout], which uses a delegate to control the layout of\na single child.\n* [CustomMultiChildLayout], which uses a delegate to position multiple\nchildren.\n* [Flow], which provides paint-time control of its children using transform\nmatrices.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "How to align the non-positioned children in the stack.\n\nThe non-positioned children are placed relative to each other such that\nthe points determined by [alignment] are co-located. For example, if the\n[alignment] is [FractionalOffset.topLeft], then the top left corner of\neach non-positioned child will be located at the same global coordinate."
      },
      {
        "name": "overflow",
        "type": "Overflow",
        "named": true,
        "docs": "Whether overflowing children should be clipped. See [Overflow].\n\nSome children in a stack might overflow its box. When this flag is set to\n[Overflow.clipped], children cannot paint outside of the stack's box."
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      }
    ]
  },
  "StatefulBuilder": {
    "name": "StatefulBuilder",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A platonic widget that both has state and calls a closure to obtain its child widget.\n\nSee also:\n\n* [Builder], the platonic stateless widget.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "builder",
        "type": "StatefulWidgetBuilder",
        "named": true,
        "required": true,
        "docs": "Called to obtain the child widget.\n\nThis function is called whenever this widget is included in its parent's\nbuild and the old widget (if any) that it synchronizes with has a distinct\nobject identity. Typically the parent's build method will construct\na new tree of widgets and so a new Builder child will not be [identical]\nto the corresponding old one."
      }
    ]
  },
  "StatefulWidget": {
    "name": "StatefulWidget",
    "package": "widgets",
    "parent": "Widget",
    "abstract": true,
    "docs": "A widget that has mutable state.\n\nState is information that (1) can be read synchronously when the widget is\nbuilt and (2) might change during the lifetime of the widget. It is the\nresponsibility of the widget implementer to ensure that the [State] is\npromptly notified when such state changes, using [State.setState].\n\nA stateful widget is a widget that describes part of the user interface by\nbuilding a constellation of other widgets that describe the user interface\nmore concretely. The building process continues recursively until the\ndescription of the user interface is fully concrete (e.g., consists\nentirely of [RenderObjectWidget]s, which describe concrete [RenderObject]s).\n\nStateful widget are useful when the part of the user interface you are\ndescribing can change dynamically, e.g. due to having an internal\nclock-driven state, or depending on some system state. For compositions that\ndepend only on the configuration information in the object itself and the\n[BuildContext] in which the widget is inflated, consider using\n[StatelessWidget].\n\n[StatefulWidget] instances themselves are immutable and store their mutable\nstate either in separate [State] objects that are created by the\n[createState] method, or in objects to which that [State] subscribes, for\nexample [Stream] or [ChangeNotifier] objects, to which references are stored\nin final fields on the [StatefulWidget] itself.\n\nThe framework calls [createState] whenever it inflates a\n[StatefulWidget], which means that multiple [State] objects might be\nassociated with the same [StatefulWidget] if that widget has been inserted\ninto the tree in multiple places. Similarly, if a [StatefulWidget] is\nremoved from the tree and later inserted in to the tree again, the framework\nwill call [createState] again to create a fresh [State] object, simplifying\nthe lifecycle of [State] objects.\n\nA [StatefulWidget] keeps the same [State] object when moving from one\nlocation in the tree to another if its creator used a [GlobalKey] for its\n[key]. Because a widget with a [GlobalKey] can be used in at most one\nlocation in the tree, a widget that uses a [GlobalKey] has at most one\nassociated element. The framework takes advantage of this property when\nmoving a widget with a global key from one location in the tree to another\nby grafting the (unique) subtree associated with that widget from the old\nlocation to the new location (instead of recreating the subtree at the new\nlocation). The [State] objects associated with [StatefulWidget] are grafted\nalong with the rest of the subtree, which means the [State] object is reused\n(instead of being recreated) in the new location. However, in order to be\neligible for grafting, the widget might be inserted into the new location in\nthe same animation frame in which it was removed from the old location.\n\nSee also:\n\n* [State], where the logic behind a [StatefulWidget] is hosted.\n* [StatelessWidget], for widgets that always build the same way given a\nparticular configuration and ambient state.\n* [InheritedWidget], for widgets that introduce ambient state that can\nbe read by descendant widgets.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      }
    ]
  },
  "StatelessWidget": {
    "name": "StatelessWidget",
    "package": "widgets",
    "parent": "Widget",
    "abstract": true,
    "docs": "A widget that does not require mutable state.\n\nA stateless widget is a widget that describes part of the user interface by\nbuilding a constellation of other widgets that describe the user interface\nmore concretely. The building process continues recursively until the\ndescription of the user interface is fully concrete (e.g., consists\nentirely of [RenderObjectWidget]s, which describe concrete [RenderObject]s).\n\nStateless widget are useful when the part of the user interface you are\ndescribing does not depend on anything other than the configuration\ninformation in the object itself and the [BuildContext] in which the widget\nis inflated. For compositions that can change dynamically, e.g. due to\nhaving an internal clock-driven state, or depending on some system state,\nconsider using [StatefulWidget].\n\nSee also:\n\n* [StatefulWidget] and [State], for widgets that can build differently\nseveral times over their lifetime.\n* [InheritedWidget], for widgets that introduce ambient state that can\nbe read by descendant widgets.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      }
    ]
  },
  "StatusTransitionWidget": {
    "name": "StatusTransitionWidget",
    "package": "widgets",
    "parent": "StatefulWidget",
    "abstract": true,
    "docs": "A widget that rebuilds when the given animation changes status.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "animation",
        "type": "Animation",
        "named": true,
        "required": true,
        "docs": "The animation to which this widget is listening."
      }
    ]
  },
  "Stepper": {
    "name": "Stepper",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material stepper widget that displays progress through a sequence of\nsteps. Steppers are particularly useful in the case of forms where one step\nrequires the completion of another one, or where multiple steps need to be\ncompleted in order to submit the whole form.\n\nThe widget is a flexible wrapper. A parent class should pass [currentStep]\nto this widget based on some logic triggered by the three callbacks that it\nprovides.\n\nSee also:\n\n* [Step]\n* <https://material.google.com/components/steppers.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "steps",
        "type": "List",
        "named": true,
        "docs": "The steps of the stepper whose titles, subtitles, icons always get shown.\n\nThe length of [steps] must not change."
      },
      {
        "name": "type",
        "type": "StepperType",
        "named": true,
        "docs": "The type of stepper that determines the layout. In the case of\n[StepperType.horizontal], the content of the current step is displayed\nunderneath as opposed to the [StepperType.vertical] case where it is\ndisplayed in-between."
      },
      {
        "name": "currentStep",
        "type": "int",
        "named": true,
        "docs": "The index into [steps] of the current step whose content is displayed."
      },
      {
        "name": "onStepTapped",
        "type": "ValueChanged",
        "named": true,
        "docs": "The callback called when a step is tapped, with its index passed as\nan argument."
      },
      {
        "name": "onStepContinue",
        "type": "dynamic",
        "named": true,
        "docs": "The callback called when the 'continue' button is tapped.\n\nIf null, the 'continue' button will be disabled."
      },
      {
        "name": "onStepCancel",
        "type": "dynamic",
        "named": true,
        "docs": "The callback called when the 'cancel' button is tapped.\n\nIf null, the 'cancel' button will be disabled."
      }
    ]
  },
  "StreamBuilder": {
    "name": "StreamBuilder",
    "package": "widgets",
    "parent": "StreamBuilderBase",
    "docs": "Widget that builds itself based on the latest snapshot of interaction with\na [Stream].\n\nWidget rebuilding is scheduled by each interaction, using [State.setState],\nbut is otherwise decoupled from the timing of the stream. The [build] method\nis called at the discretion of the Flutter pipeline, and will thus receive a\ntiming-dependent sub-sequence of the snapshots that represent the\ninteraction with the stream.\n\nAs an example, when interacting with a stream producing the integers\n0 through 9, the [build] method may be called with any ordered sub-sequence\nof the following snapshots that includes the last one (the one with\nConnectionState.done):\n\n* `new AsyncSnapshot<int>(ConnectionState.waiting, null, null)`\n* `new AsyncSnapshot<int>(ConnectionState.active, 0, null)`\n* `new AsyncSnapshot<int>(ConnectionState.active, 1, null)`\n* ...\n* `new AsyncSnapshot<int>(ConnectionState.active, 9, null)`\n* `new AsyncSnapshot<int>(ConnectionState.done, 9, null)`\n\nThe actual sequence of invocations of [build] depends on the relative timing\nof events produced by the stream and the build rate of the Flutter pipeline.\n\nChanging the [StreamBuilder] configuration to another stream during event\ngeneration introduces snapshot pairs of the form\n\n* `new AsyncSnapshot<int>(ConnectionState.none, 5, null)`\n* `new AsyncSnapshot<int>(ConnectionState.waiting, 5, null)`\n\nThe latter will be produced only when the new stream is non-`null`. The former\nonly when the old stream is non-`null`.\n\nThe stream may produce errors, resulting in snapshots of the form\n\n* `new AsyncSnapshot<int>(ConnectionState.active, null, 'some error')`\n\nThe data and error fields of snapshots produced are only changed when the\nstate is `ConnectionState.active`.\n\nSee also:\n\n* [StreamBuilderBase], which supports widget building based on a computation\nthat spans all interactions made with the stream.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "stream",
        "type": "Stream",
        "named": true
      },
      {
        "name": "builder",
        "type": "AsyncWidgetBuilder",
        "named": true,
        "required": true,
        "docs": "The build strategy currently used by this builder. Cannot be `null`."
      }
    ]
  },
  "StreamBuilderBase": {
    "name": "StreamBuilderBase",
    "package": "widgets",
    "parent": "StatefulWidget",
    "abstract": true,
    "docs": "Base class for widgets that build themselves based on interaction with\na specified [Stream].\n\nA [StreamBuilderBase] is stateful and maintains a summary of the interaction\nso far. The type of the summary and how it is updated with each interaction\nis defined by sub-classes.\n\nExamples of summaries include:\n\n* the running average of a stream of integers;\n* the current direction and speed based on a stream of geolocation data;\n* a graph displaying data points from a stream.\n\nIn general, the summary is the result of a fold computation over the data\nitems and errors received from the stream along with pseudo-events\nrepresenting termination or change of stream. The initial summary is\nspecified by sub-classes by overriding [initial]. The summary updates on\nreceipt of stream data and errors are specified by overriding [afterData] and\n[afterError], respectively. If needed, the summary may be updated on stream\ntermination by overriding [afterDone]. Finally, the summary may be updated\non change of stream by overriding [afterConnected] and [afterConnected].\n\n[T] is the type of stream events.\n[S] is the type of interaction summary.\n\nSee also:\n\n* [StreamBuilder], which is specialized to the case where only the most\nrecent interaction is needed for widget building.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "stream",
        "type": "Stream",
        "named": true,
        "docs": "The asynchronous computation to which this builder is currently connected,\npossibly `null`. When changed, the current summary is updated using\n[afterDisconnecting], if the previous stream was not `null`, followed by\n[afterConnecting], if the new stream is not `null`."
      }
    ]
  },
  "Switch": {
    "name": "Switch",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design switch.\n\nUsed to toggle the on/off state of a single setting.\n\nThe switch itself does not maintain any state. Instead, when the state of\nthe switch changes, the widget calls the [onChanged] callback. Most widgets\nthat use a switch will listen for the [onChanged] callback and rebuild the\nswitch with a new [value] to update the visual appearance of the switch.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [CheckBox]\n* [Radio]\n* [Slider]\n* <https://material.google.com/components/selection-controls.html#selection-controls-switch>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "value",
        "type": "bool",
        "named": true,
        "required": true,
        "docs": "Whether this switch is on or off."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the user toggles with switch on or off.\n\nThe switch passes the new value to the callback but does not actually\nchange state until the parent widget rebuilds the switch with the new\nvalue.\n\nIf null, the switch will be displayed as disabled.\n\nThe callback provided to onChanged should update the state of the parent\n[StatefulWidget] using the [State.setState] method, so that the parent\ngets rebuilt; for example:\n\n```dart\nnew Switch(\nvalue: _giveVerse,\nonChanged: (bool newValue) {\nsetState(() {\n_giveVerse = newValue;\n});\n},\n),\n```"
      },
      {
        "name": "activeColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to use when this switch is on.\n\nDefaults to accent color of the current [Theme]."
      },
      {
        "name": "activeThumbImage",
        "type": "ImageProvider",
        "named": true,
        "docs": "An image to use on the thumb of this switch when the switch is on."
      },
      {
        "name": "inactiveThumbImage",
        "type": "ImageProvider",
        "named": true,
        "docs": "An image to use on the thumb of this switch when the switch is off."
      }
    ]
  },
  "Tab": {
    "name": "Tab",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A material design [TabBar] tab. If both [icon] and [text] are\nprovided, the text is displayed below the icon.\n\nSee also:\n\n* [TabBar], which displays a row of tabs.\n* [TabBarView], which displays a widget for the currently selected tab.\n* [TabController], which coordinates tab selection between a [TabBar] and a [TabBarView].\n* <https://material.google.com/components/tabs.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "text",
        "type": "String",
        "named": true,
        "docs": "The text to display as the tab's label."
      },
      {
        "name": "icon",
        "type": "Widget",
        "named": true,
        "docs": "An icon to display as the tab's label."
      }
    ]
  },
  "TabBar": {
    "name": "TabBar",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design widget that displays a horizontal row of tabs.\n\nTypically created as part of an [AppBar] and in conjuction with a\n[TabBarView].\n\nIf a [TabController] is not provided, then there must be a\n[DefaultTabController] ancestor.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [TabBarView], which displays the contents that the tab bar is selecting\nbetween.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "tabs",
        "type": "List",
        "named": true,
        "required": true,
        "docs": "Typically a list of [Tab] widgets."
      },
      {
        "name": "controller",
        "type": "TabController",
        "named": true,
        "docs": "This widget's selection and animation state.\n\nIf [TabController] is not provided, then the value of [DefaultTabController.of]\nwill be used."
      },
      {
        "name": "isScrollable",
        "type": "bool",
        "named": true,
        "docs": "Whether this tab bar can be scrolled horizontally.\n\nIf [isScrollable] is true then each tab is as wide as needed for its label\nand the entire [TabBar] is scrollable. Otherwise each tab gets an equal\nshare of the available space."
      },
      {
        "name": "indicatorColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color of the line that appears below the selected tab. If this parameter\nis null then the value of the Theme's indicatorColor property is used."
      },
      {
        "name": "labelColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color of selected tab labels.\n\nUnselected tab labels are rendered with the same color rendered at 70%\nopacity unless [unselectedLabelColor] is non-null.\n\nIf this parameter is null then the color of the theme's body2 text color\nis used."
      },
      {
        "name": "labelStyle",
        "type": "TextStyle",
        "named": true,
        "docs": "The text style of the selected tab labels. If [unselectedLabelStyle] is\nnull then this text style will be used for both selected and unselected\nlabel styles.\n\nIf this property is null then the text style of the theme's body2\ndefinition is used."
      },
      {
        "name": "unselectedLabelColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color of unselected tab labels.\n\nIf this property is null, Unselected tab labels are rendered with the\n[labelColor] rendered at 70% opacity."
      },
      {
        "name": "unselectedLabelStyle",
        "type": "TextStyle",
        "named": true,
        "docs": "The text style of the unselected tab labels\n\nIf this property is null then the [labelStyle] value is used. If [labelStyle]\nis null then the text style of the theme's body2 definition is used."
      }
    ]
  },
  "TabBarView": {
    "name": "TabBarView",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A page view that displays the widget which corresponds to the currently\nselected tab. Typically used in conjuction with a [TabBar].\n\nIf a [TabController] is not provided, then there must be a [DefaultTabController]\nancestor.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true,
        "required": true,
        "docs": "One widget per tab."
      },
      {
        "name": "controller",
        "type": "TabController",
        "named": true,
        "docs": "This widget's selection and animation state.\n\nIf [TabController] is not provided, then the value of [DefaultTabController.of]\nwill be used."
      }
    ]
  },
  "TabPageSelector": {
    "name": "TabPageSelector",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "Displays a row of small circular indicators, one per tab. The selected\ntab's indicator is highlighted. Often used in conjuction with a [TabBarView].\n\nIf a [TabController] is not provided, then there must be a [DefaultTabController]\nancestor.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "controller",
        "type": "TabController",
        "named": true,
        "docs": "This widget's selection and animation state.\n\nIf [TabController] is not provided, then the value of [DefaultTabController.of]\nwill be used."
      }
    ]
  },
  "Table": {
    "name": "Table",
    "package": "widgets",
    "parent": "RenderObjectWidget",
    "docs": "A widget that uses the table layout algorithm for its children.\n\nIf you only have one row, the [Row] widget is more appropriate. If you only\nhave one column, the [SliverList] or [Column] widgets will be more\nappropriate.\n\nRows size vertically based on their contents. To control the column widths,\nuse the [columnWidths] property.\n\nFor more details about the table layout algorithm, see [RenderTable].\nTo control the alignment of children, see [TableCell].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true
      },
      {
        "name": "columnWidths",
        "type": "Map",
        "named": true,
        "docs": "How the horizontal extents of the columns of this table should be determined.\n\nIf the [Map] has a null entry for a given column, the table uses the\n[defaultColumnWidth] instead. By default, that uses flex sizing to\ndistribute free space equally among the columns.\n\nThe [FixedColumnWidth] class can be used to specify a specific width in\npixels. That is the cheapest way to size a table's columns.\n\nThe layout performance of the table depends critically on which column\nsizing algorithms are used here. In particular, [IntrinsicColumnWidth] is\nquite expensive because it needs to measure each cell in the column to\ndetermine the intrinsic size of the column."
      },
      {
        "name": "defaultColumnWidth",
        "type": "TableColumnWidth",
        "named": true,
        "docs": "How to determine with widths of columns that don't have an explicit sizing algorithm.\n\nSpecifically, the [defaultColumnWidth] is used for column `i` if\n`columnWidths[i]` is null."
      },
      {
        "name": "border",
        "type": "TableBorder",
        "named": true,
        "docs": "The style to use when painting the boundary and interior divisions of the table."
      },
      {
        "name": "defaultVerticalAlignment",
        "type": "TableCellVerticalAlignment",
        "named": true,
        "docs": "How cells that do not explicitly specify a vertical alignment are aligned vertically."
      },
      {
        "name": "textBaseline",
        "type": "dynamic",
        "named": true,
        "docs": "The text baseline to use when aligning rows using [TableCellVerticalAlignment.baseline]."
      }
    ]
  },
  "TableCell": {
    "name": "TableCell",
    "package": "widgets",
    "parent": "ParentDataWidget",
    "docs": "A widget that controls how a child of a [Table] is aligned.\n\nA [TableCell] widget must be a descendant of a [Table], and the path from\nthe [TableCell] widget to its enclosing [Table] must contain only\n[TableRow]s, [StatelessWidget]s, or [StatefulWidget]s (not\nother kinds of widgets, like [RenderObjectWidget]s).",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "verticalAlignment",
        "type": "TableCellVerticalAlignment",
        "named": true,
        "docs": "How this cell is aligned vertically."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true
      }
    ]
  },
  "TableRowInkWell": {
    "name": "TableRowInkWell",
    "package": "material",
    "parent": "InkResponse",
    "docs": "A rectangular area of a Material that responds to touch but clips\nits ink splashes to the current table row of the nearest table.\n\nMust have an ancestor [Material] widget in which to cause ink\nreactions and an ancestor [Table] widget to establish a row.\n\nThe [TableRowInkWell] must be in the same coordinate space (modulo\ntranslations) as the [Table]. If it's rotated or scaled or\notherwise transformed, it will not be able to describe the\nrectangle of the row in its own coordinate system as a [Rect], and\nthus the splash will not occur. (In general, this is easy to\nachieve: just put the [TableRowInkWell] as the direct child of the\n[Table], and put the other contents of the cell inside it.)",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      },
      {
        "name": "onTap",
        "type": "GestureTapCallback",
        "named": true
      },
      {
        "name": "onDoubleTap",
        "type": "GestureTapCallback",
        "named": true
      },
      {
        "name": "onLongPress",
        "type": "GestureLongPressCallback",
        "named": true
      },
      {
        "name": "onHighlightChanged",
        "type": "ValueChanged",
        "named": true
      }
    ]
  },
  "Text": {
    "name": "Text",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A run of text with a single style.\n\nThe [Text] widget displays a string of text with single style. The string\nmight break across multiple lines or might all be displayed on the same line\ndepending on the layout constraints.\n\nThe [style] argument is optional. When omitted, the text will use the style\nfrom the closest enclosing [DefaultTextStyle]. If the given style's\n[TextStyle.inherit] property is true, the given style will be merged with\nthe closest enclosing [DefaultTextStyle]. This merging behavior is useful,\nfor example, to make the text bold while using the default font family and\nsize.\n\nTo display text that uses multiple styles (e.g., a paragraph with some bold\nwords), use [RichText].\n\nSee also:\n\n* [RichText]\n* [DefaultTextStyle]",
    "properties": [
      {
        "name": "data",
        "type": "String",
        "required": true,
        "docs": "The text to display."
      },
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "style",
        "type": "TextStyle",
        "named": true,
        "docs": "If non-null, the style to use for this text.\n\nIf the style's \"inherit\" property is true, the style will be merged with\nthe closest enclosing [DefaultTextStyle]. Otherwise, the style will\nreplace the closest enclosing [DefaultTextStyle]."
      },
      {
        "name": "textAlign",
        "type": "dynamic",
        "named": true,
        "docs": "How the text should be aligned horizontally."
      },
      {
        "name": "softWrap",
        "type": "bool",
        "named": true,
        "docs": "Whether the text should break at soft line breaks.\n\nIf false, the glyphs in the text will be positioned as if there was unlimited horizontal space."
      },
      {
        "name": "overflow",
        "type": "TextOverflow",
        "named": true,
        "docs": "How visual overflow should be handled."
      },
      {
        "name": "textScaleFactor",
        "type": "double",
        "named": true,
        "docs": "The number of font pixels for each logical pixel.\n\nFor example, if the text scale factor is 1.5, text will be 50% larger than\nthe specified font size.\n\nDefaults to [MediaQuery.textScaleFactor]."
      },
      {
        "name": "maxLines",
        "type": "int",
        "named": true,
        "docs": "An optional maximum number of lines the text is allowed to take up.\nIf the text exceeds the given number of lines, it will be truncated according\nto [overflow]."
      }
    ]
  },
  "TextField": {
    "name": "TextField",
    "package": "material",
    "parent": "FormField",
    "docs": "A [FormField] that contains an [Input].\n\nThis is a convenience widget that simply wraps an [Input] widget in a\n[FormField]. The [FormField] maintains the current value of the [Input] so\nthat you don't need to manage it yourself.\n\nA [Form] ancestor is not required. The [Form] simply makes it easier to\nsave, reset, or validate multiple fields at once. To use without a [Form],\npass a [GlobalKey] to the constructor and use [GlobalKey.currentState] to\nsave or reset the form field.\n\nTo see the use of [TextField], compare these two ways of a implementing\na simple two text field form.\n\nUsing [TextField]:\n\n```dart\nString _firstName, _lastName;\nGlobalKey<FormState> _formKey = new GlobalKey<FormState>();\n...\nnew Form(\nkey: _formKey,\nchild: new Row(\nchildren: <Widget>[\nnew TextField(\nlabelText: 'First Name',\nonSaved: (InputValue value) { _firstName = value.text; }\n),\nnew TextField(\nlabelText: 'Last Name',\nonSaved: (InputValue value) { _lastName = value.text; }\n),\nnew RaisedButton(\nchild: new Text('SUBMIT'),\n// Instead of _formKey.currentState, you could wrap the\n// RaisedButton in a Builder widget to get access to a BuildContext,\n// and use Form.of(context).\nonPressed: () { _formKey.currentState.save(); },\n),\n)\n)\n```\n\nUsing [Input] directly:\n\n```dart\nString _firstName, _lastName;\nInputValue _firstNameValue = const InputValue();\nInputValue _lastNameValue = const InputValue();\n...\nnew Row(\nchildren: <Widget>[\nnew Input(\nvalue: _firstNameValue,\nlabelText: 'First Name',\nonChanged: (InputValue value) { setState( () { _firstNameValue = value; } ); }\n),\nnew Input(\nvalue: _lastNameValue,\nlabelText: 'Last Name',\nonChanged: (InputValue value) { setState( () { _lastNameValue = value; } ); }\n),\nnew RaisedButton(\nchild: new Text('SUBMIT'),\nonPressed: () {\n_firstName = _firstNameValue.text;\n_lastName = _lastNameValue.text;\n},\n),\n)\n```",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "focusKey",
        "type": "GlobalKey",
        "named": true
      },
      {
        "name": "keyboardType",
        "type": "TextInputType",
        "named": true
      },
      {
        "name": "icon",
        "type": "Icon",
        "named": true
      },
      {
        "name": "labelText",
        "type": "String",
        "named": true
      },
      {
        "name": "hintText",
        "type": "String",
        "named": true
      },
      {
        "name": "style",
        "type": "TextStyle",
        "named": true
      },
      {
        "name": "obscureText",
        "type": "bool",
        "named": true
      },
      {
        "name": "isDense",
        "type": "bool",
        "named": true
      },
      {
        "name": "autofocus",
        "type": "bool",
        "named": true
      },
      {
        "name": "maxLines",
        "type": "int",
        "named": true
      },
      {
        "name": "initialValue",
        "type": "InputValue",
        "named": true
      },
      {
        "name": "onSaved",
        "type": "FormFieldSetter",
        "named": true
      },
      {
        "name": "validator",
        "type": "FormFieldValidator",
        "named": true
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true
      }
    ]
  },
  "Theme": {
    "name": "Theme",
    "package": "material",
    "parent": "InheritedWidget",
    "docs": "Applies a theme to descendant widgets.\n\nA theme describes the colors and typographic choices of an application.\n\nDescendant widgets obtain the current theme's [ThemeData] object using\n[Theme.of]. When a widget uses [Theme.of], it is automatically rebuilt if\nthe theme later changes, so that the changes can be applied.\n\nSee also:\n\n* [ThemeData], which describes the actual configuration of a theme.\n* [AnimatedTheme], which animates the [ThemeData] when it changes rather\nthan changing the theme all at once.\n* [MaterialApp], which includes an [AnimatedTheme] widget configured via\nthe [MaterialApp.theme] argument.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "data",
        "type": "ThemeData",
        "named": true,
        "required": true,
        "docs": "Specifies the color and typography values for descendant widgets."
      },
      {
        "name": "isMaterialAppTheme",
        "type": "bool",
        "named": true,
        "docs": "True if this theme was installed by the [MaterialApp].\n\nWhen an app uses the [Navigator] to push a route, the route's widgets\nwill only inherit from the app's theme, even though the widget that\ntriggered the push may inherit from a theme that \"shadows\" the app's\ntheme because it's deeper in the widget tree. Apps can find the shadowing\ntheme with `Theme.of(context, shadowThemeOnly: true)` and pass it along\nto the class that creates a route's widgets. Material widgets that push\nroutes, like [PopupMenuButton] and [DropdownButton], do this."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "TickerMode": {
    "name": "TickerMode",
    "package": "widgets",
    "parent": "InheritedWidget",
    "docs": "Enables or disables tickers (and thus animation controllers) in the widget\nsubtree.\n\nThis only works if [AnimationController] objects are created using\nwidget-aware ticker providers. For example, using a\n[TickerProviderStateMixin] or a [SingleTickerProviderStateMixin].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "enabled",
        "type": "bool",
        "named": true,
        "required": true,
        "docs": "The current ticker mode of this subtree.\n\nIf true, then tickers in this subtree will tick.\n\nIf false, then tickers in this subtree will not tick. Animations driven by\nsuch tickers are not paused, they just don't call their callbacks. Time\nstill elapses."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "Title": {
    "name": "Title",
    "package": "widgets",
    "parent": "StatelessWidget",
    "docs": "A widget that describes this app in the operating system.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "title",
        "type": "String",
        "named": true,
        "docs": "A one-line description of this app for use in the window manager."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "docs": "A color that the window manager should use to identify this app."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "Tooltip": {
    "name": "Tooltip",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design tooltip.\n\nTooltips provide text labels that help explain the function of a button or\nother user interface action. Wrap the button in a [Tooltip] widget to\nshow a label when the widget long pressed (or when the user takes some\nother appropriate action).\n\nMany widgets, such as [IconButton], [FloatingActionButton], and\n[PopupMenuButton] have a `tooltip` property that, when non-null, causes the\nwidget to include a [Tooltip] in its build.\n\nTooltips improve the accessibility of visual widgets by proving a textual\nrepresentation of the widget, which, for example, can be vocalized by a\nscreen reader.\n\nSee also:\n\n* <https://material.google.com/components/tooltips.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "message",
        "type": "String",
        "named": true,
        "docs": "The text to display in the tooltip."
      },
      {
        "name": "height",
        "type": "double",
        "named": true,
        "docs": "The amount of vertical space the tooltip should occupy (inside its padding)."
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "The amount of space by which to inset the child.\n\nDefaults to 16.0 logical pixels in each direction."
      },
      {
        "name": "verticalOffset",
        "type": "double",
        "named": true,
        "docs": "The amount of vertical distance between the widget and the displayed tooltip."
      },
      {
        "name": "preferBelow",
        "type": "bool",
        "named": true,
        "docs": "Whether the tooltip defaults to being displayed below the widget.\n\nDefaults to true. If there is insufficient space to display the tooltip in\nthe preferred direction, the tooltip will be displayed in the opposite\ndirection."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "docs": "The widget below this widget in the tree."
      }
    ]
  },
  "Transform": {
    "name": "Transform",
    "package": "widgets",
    "parent": "SingleChildRenderObjectWidget",
    "docs": "A widget that applies a transformation before painting its child.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "transform",
        "type": "Matrix4",
        "named": true,
        "required": true,
        "docs": "The matrix to transform the child by during painting."
      },
      {
        "name": "origin",
        "type": "dynamic",
        "named": true,
        "docs": "The origin of the coordinate system (relative to the upper left corder of\nthis render object) in which to apply the matrix.\n\nSetting an origin is equivalent to conjugating the transform matrix by a\ntranslation. This property is provided just for convenience."
      },
      {
        "name": "alignment",
        "type": "FractionalOffset",
        "named": true,
        "docs": "The alignment of the origin, relative to the size of the box.\n\nThis is equivalent to setting an origin based on the size of the box.\nIf it is specified at the same time as an offset, both are applied."
      },
      {
        "name": "transformHitTests",
        "type": "bool",
        "named": true,
        "docs": "Whether to apply the translation when performing hit tests."
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true
      }
    ]
  },
  "TwoLevelList": {
    "name": "TwoLevelList",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "A scrollable list of items that can expand and collapse.\n\nSee also:\n\n* [TwoLevelSublist]\n* [TwoLevelListItem]\n* [ListView], for lists that only have one level.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "children",
        "type": "List",
        "named": true,
        "docs": "The widgets to display in this list.\n\nTypically [TwoLevelListItem] or [TwoLevelSublist] widgets."
      },
      {
        "name": "type",
        "type": "MaterialListType",
        "named": true,
        "docs": "The kind of [ListItem] contained in this list."
      },
      {
        "name": "padding",
        "type": "EdgeInsets",
        "named": true,
        "docs": "The amount of space by which to inset the children inside the viewport."
      }
    ]
  },
  "TwoLevelListItem": {
    "name": "TwoLevelListItem",
    "package": "material",
    "parent": "StatelessWidget",
    "docs": "An item in a [TwoLevelList] or a [TwoLevelSublist].\n\nA two-level list item is similar to a [ListItem], but a two-level list item\nautomatically sizes itself to fit properly within its ancestor\n[TwoLevelList].\n\nSee also:\n\n* [TwoLevelList]\n* [TwoLevelSublist]\n* [ListItem]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "leading",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display before the title.\n\nTypically a [CircleAvatar] widget."
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The primary content of the list item.\n\nTypically a [Text] widget."
      },
      {
        "name": "trailing",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display after the title.\n\nTypically an [Icon] widget."
      },
      {
        "name": "enabled",
        "type": "bool",
        "named": true,
        "docs": "Whether this list item is interactive.\n\nIf false, this list item is styled with the disabled color from the\ncurrent [Theme] and the [onTap] and [onLongPress] callbacks are\ninoperative."
      },
      {
        "name": "onTap",
        "type": "GestureTapCallback",
        "named": true,
        "docs": "Called when the user taps this list item.\n\nInoperative if [enabled] is false."
      },
      {
        "name": "onLongPress",
        "type": "GestureLongPressCallback",
        "named": true,
        "docs": "Called when the user long-presses on this list item.\n\nInoperative if [enabled] is false."
      }
    ]
  },
  "TwoLevelSublist": {
    "name": "TwoLevelSublist",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "An item in a [TwoLevelList] that can expand and collapse.\n\nA two-level sublist is similar to a [ListItem], but the trailing widget is\na button that expands or collapses a sublist of items.\n\nSee also:\n\n* [TwoLevelList]\n* [TwoLevelListItem]\n* [ListItem]",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "leading",
        "type": "Widget",
        "named": true,
        "docs": "A widget to display before the title.\n\nTypically a [CircleAvatar] widget."
      },
      {
        "name": "title",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The primary content of the list item.\n\nTypically a [Text] widget."
      },
      {
        "name": "backgroundColor",
        "type": "dynamic",
        "named": true,
        "docs": "The color to display behind the sublist when expanded."
      },
      {
        "name": "onOpenChanged",
        "type": "ValueChanged",
        "named": true,
        "docs": "Called when the sublist expands or collapses.\n\nWhen the sublist starts expanding, this function is called with the value\n`true`. When the sublist starts collapsing, this function is called with\nthe value false."
      },
      {
        "name": "children",
        "type": "List",
        "named": true,
        "docs": "The widgets that are displayed when the sublist expands.\n\nTypically [TwoLevelListItem] widgets."
      }
    ]
  },
  "UniqueWidget": {
    "name": "UniqueWidget",
    "package": "widgets",
    "parent": "StatefulWidget",
    "abstract": true,
    "docs": "Base class for stateful widgets that have exactly one inflated instance in\nthe tree.\n\nSuch widgets must be given a [GlobalKey]. This key can be generated by the\nsubclass from its [Type] object, e.g. by calling `super(key: new\nGlobalObjectKey(MyWidget))` where `MyWidget` is the name of the subclass.\n\nSince only one instance can be inflated at a time, there is only ever one\ncorresponding [State] object. That object is exposed, for convenience, via\nthe [currentState] property.\n\nWhen subclassing [UniqueWidget], provide the corresponding [State] subclass\nas the type argument.",
    "properties": [
      {
        "name": "key",
        "type": "GlobalKey",
        "named": true,
        "required": true
      }
    ]
  },
  "UserAccountsDrawerHeader": {
    "name": "UserAccountsDrawerHeader",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A material design [Drawer] header that identifies the app's user.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [DrawerHeader], for a drawer header that doesn't show user acounts\n* <https://material.google.com/patterns/navigation-drawer.html>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "decoration",
        "type": "Decoration",
        "named": true,
        "docs": "The header's background. If decoration is null then a [BoxDecoration]\nwith its background color set to the current theme's primaryColor is used."
      },
      {
        "name": "currentAccountPicture",
        "type": "Widget",
        "named": true,
        "docs": "A widget placed in the upper-left corner that represents the current\nuser's account. Normally a [CircleAvatar]."
      },
      {
        "name": "otherAccountsPictures",
        "type": "List",
        "named": true,
        "docs": "A list of widgets that represent the current user's other accounts.\nUp to three of these widgets will be arranged in a row in the header's\nupper-right corner. Normally a list of [CircleAvatar] widgets."
      },
      {
        "name": "accountName",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "A widget that represents the user's current account name. It is\ndisplayed on the left, below the [currentAccountPicture]."
      },
      {
        "name": "accountEmail",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "A widget that represents the email address of the user's current account.\nIt is displayed on the left, below the [accountName]."
      },
      {
        "name": "onDetailsPressed",
        "type": "dynamic",
        "named": true,
        "docs": "A callback that is called when the horizontal area which contains the\n[accountName] and [accountEmail] is tapped."
      }
    ]
  },
  "Viewport": {
    "name": "Viewport",
    "package": "widgets",
    "parent": "MultiChildRenderObjectWidget",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "axisDirection",
        "type": "AxisDirection",
        "named": true
      },
      {
        "name": "anchor",
        "type": "double",
        "named": true
      },
      {
        "name": "offset",
        "type": "ViewportOffset",
        "named": true,
        "required": true
      },
      {
        "name": "center",
        "type": "Key",
        "named": true
      },
      {
        "name": "slivers",
        "type": "List",
        "named": true
      }
    ]
  },
  "Widget": {
    "name": "Widget",
    "package": "widgets",
    "abstract": true,
    "docs": "Describes the configuration for an [Element].\n\nWidgets are the central class hierarchy in the Flutter framework. A widget\nis an immutable description of part of a user interface. Widgets can be\ninflated into elements, which manage the underlying render tree.\n\nWidgets themselves have no mutable state (all their fields must be final).\nIf you wish to associate mutable state with a widget, consider using a\n[StatefulWidget], which creates a [State] object (via\n[StatefulWidget.createState]) whenever it is inflated into an element and\nincorporated into the tree.\n\nA given widget can be included in the tree zero or more times. In particular\na given widget can be placed in the tree multiple times. Each time a widget\nis placed in the tree, it is inflated into an [Element], which means a\nwidget that is incorporated into the tree multiple times will be inflated\nmultiple times.\n\nThe [key] property controls how one widget replaces another widget in the\ntree. If the [runtimeType] and [key] properties of the two widgets are\n[operator==], respectively, then the new widget replaces the old widget by\nupdating the underlying element (i.e., by calling [Element.update] with the\nnew widget). Otherwise, the old element is removed from the tree, the new\nwidget is inflated into an element, and the new element is inserted into the\ntree.\n\nSee also:\n\n* [StatefulWidget] and [State], for widgets that can build differently\nseveral times over their lifetime.\n* [InheritedWidget], for widgets that introduce ambient state that can\nbe read by descendant widgets.\n* [StatelessWidget], for widgets that always build the same way given a\nparticular configuration and ambient state.",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true,
        "docs": "Controls how one widget replaces another widget in the tree.\n\nIf the [runtimeType] and [key] properties of the two widgets are\n[operator==], respectively, then the new widget replaces the old widget by\nupdating the underlying element (i.e., by calling [Element.update] with the\nnew widget). Otherwise, the old element is removed from the tree, the new\nwidget is inflated into an element, and the new element is inserted into the\ntree.\n\nUsing a [GlobalKey] as the widget's [key] allows the element to be moved\naround the tree (changing parent) without losing state. When a new widget\nis found (its key and type do not match a previous widget in the same\nlocation), but there was a widget with that same global key elsewhere in\nthe tree in the previous frame, then that widget's element is moved to the\nnew location."
      }
    ]
  },
  "WidgetToRenderBoxAdapter": {
    "name": "WidgetToRenderBoxAdapter",
    "package": "widgets",
    "parent": "LeafRenderObjectWidget",
    "docs": "An adapter for placing a specific [RenderBox] in the widget tree.\n\nA given render object can be placed at most once in the widget tree. This\nwidget enforces that restriction by keying itself using a [GlobalObjectKey]\nfor the given render object.",
    "properties": [
      {
        "name": "renderBox",
        "type": "RenderBox",
        "named": true,
        "required": true
      },
      {
        "name": "onBuild",
        "type": "dynamic",
        "named": true,
        "docs": "Called when it is safe to update the render box and its descendants. If\nyou update the RenderObject subtree under this widget outside of\ninvocations of this callback, features like hit-testing will fail as the\ntree will be dirty."
      }
    ]
  },
  "WidgetsApp": {
    "name": "WidgetsApp",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "A convenience class that wraps a number of widgets that are commonly\nrequired for an application.\n\nSee also: [CheckedModeBanner], [DefaultTextStyle], [MediaQuery],\n[LocaleQuery], [Title], [Navigator], [Overlay], [SemanticsDebugger] (the\nwidgets wrapped by this one).\n\nThe [onGenerateRoute] argument is required, and corresponds to\n[Navigator.onGenerateRoute].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "onGenerateRoute",
        "type": "RouteFactory",
        "named": true,
        "required": true,
        "docs": "The route generator callback used when the app is navigated to a\nnamed route."
      },
      {
        "name": "title",
        "type": "String",
        "named": true,
        "docs": "A one-line description of this app for use in the window manager."
      },
      {
        "name": "textStyle",
        "type": "TextStyle",
        "named": true,
        "docs": "The default text style for [Text] in the application."
      },
      {
        "name": "color",
        "type": "dynamic",
        "named": true,
        "required": true,
        "docs": "The primary color to use for the application in the operating system\ninterface.\n\nFor example, on Android this is the color used for the application in the\napplication switcher."
      },
      {
        "name": "navigatorObservers",
        "type": "List",
        "named": true,
        "docs": "The list of observers for the [Navigator] created for this app."
      },
      {
        "name": "initialRoute",
        "type": "String",
        "named": true,
        "docs": "The name of the first route to show.\n\nDefaults to [Window.defaultRouteName]."
      },
      {
        "name": "onLocaleChanged",
        "type": "LocaleChangedCallback",
        "named": true,
        "docs": "Callback that is called when the operating system changes the\ncurrent locale."
      },
      {
        "name": "showPerformanceOverlay",
        "type": "bool",
        "named": true,
        "docs": "Turns on a performance overlay.\nhttps://flutter.io/debugging/#performanceoverlay"
      },
      {
        "name": "checkerboardRasterCacheImages",
        "type": "bool",
        "named": true,
        "docs": "Checkerboards raster cache images."
      },
      {
        "name": "showSemanticsDebugger",
        "type": "bool",
        "named": true,
        "docs": "Turns on an overlay that shows the accessibility information\nreported by the framework."
      },
      {
        "name": "debugShowCheckedModeBanner",
        "type": "bool",
        "named": true,
        "docs": "Turns on a \"SLOW MODE\" little banner in checked mode to indicate\nthat the app is in checked mode. This is on by default (in\nchecked mode), to turn it off, set the constructor argument to\nfalse. In release mode this has no effect.\n\nTo get this banner in your application if you're not using\nWidgetsApp, include a [CheckedModeBanner] widget in your app.\n\nThis banner is intended to avoid people complaining that your\napp is slow when it's in checked mode. In checked mode, Flutter\nenables a large number of expensive diagnostics to aid in\ndevelopment, and so performance in checked mode is not\nrepresentative of what will happen in release mode."
      }
    ]
  },
  "WillPopScope": {
    "name": "WillPopScope",
    "package": "widgets",
    "parent": "StatefulWidget",
    "docs": "Registers a callback to veto attempts by the user to dismiss the enclosing\n[ModalRoute].\n\nSee also:\n\n* [ModalRoute.addScopedWillPopCallback] and [ModalScope.removeScopedWillPopCallback],\nwhich this widget uses to register and unregister [onWillPop].",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "child",
        "type": "Widget",
        "named": true,
        "required": true,
        "docs": "The widget below this widget in the tree."
      },
      {
        "name": "onWillPop",
        "type": "WillPopCallback",
        "mutable": true,
        "named": true,
        "required": true,
        "docs": "Called to veto attempts by the user to dismiss the enclosing [ModalRoute].\n\nIf the callback returns a Future that resolves to false, the enclosing\nroute will not be popped."
      }
    ]
  },
  "YearPicker": {
    "name": "YearPicker",
    "package": "material",
    "parent": "StatefulWidget",
    "docs": "A scrollable list of years to allow picking a year.\n\nThe year picker widget is rarely used directly. Instead, consider using\n[showDatePicker], which creates a date picker dialog.\n\nRequires one of its ancestors to be a [Material] widget.\n\nSee also:\n\n* [showDatePicker]\n* <https://material.google.com/components/pickers.html#pickers-date-pickers>",
    "properties": [
      {
        "name": "key",
        "type": "Key",
        "named": true
      },
      {
        "name": "selectedDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The currently selected date.\n\nThis date is highlighted in the picker."
      },
      {
        "name": "onChanged",
        "type": "ValueChanged",
        "named": true,
        "required": true,
        "docs": "Called when the user picks a year."
      },
      {
        "name": "firstDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The earliest date the user is permitted to pick."
      },
      {
        "name": "lastDate",
        "type": "DateTime",
        "named": true,
        "required": true,
        "docs": "The latest date the user is permitted to pick."
      }
    ]
  }
}
